Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> assignment
Rule 5     statement -> expr
Rule 6     statement -> print
Rule 7     statement -> if
Rule 8     statement -> while
Rule 9     statement -> for
Rule 10    statement -> break
Rule 11    statement -> function
Rule 12    statement -> class
Rule 13    statement -> return
Rule 14    assignment -> variable ASSIGN expr
Rule 15    assignment -> variable MINEQUAL expr
Rule 16    assignment -> variable PLUSEQUAL expr
Rule 17    assignment -> variable DPLUS
Rule 18    assignment -> variable DMINUS
Rule 19    variable -> variable LBRACKET expr RBRACKET
Rule 20    variable -> ID DOT ID
Rule 21    variable -> ID
Rule 22    expr -> expr PLUS term
Rule 23    expr -> expr MINUS term
Rule 24    expr -> term
Rule 25    expr -> string
Rule 26    expr -> array
Rule 27    term -> term TIMES factor
Rule 28    term -> term DIVIDE factor
Rule 29    term -> term EDIVIDE factor
Rule 30    term -> factor
Rule 31    factor -> variable
Rule 32    factor -> NUMBER
Rule 33    factor -> len
Rule 34    factor -> call
Rule 35    factor -> LPAREN expr RPAREN
Rule 36    exprs -> exprs COMMA expr
Rule 37    exprs -> expr
Rule 38    len -> LEN LPAREN variable RPAREN
Rule 39    print -> PRINT LPAREN exprs RPAREN
Rule 40    print -> PRINT LPAREN RPAREN
Rule 41    array -> LBRACKET exprs RBRACKET
Rule 42    array -> LBRACKET RBRACKET
Rule 43    condition -> condition OR join
Rule 44    condition -> join
Rule 45    join -> join AND equality
Rule 46    join -> equality
Rule 47    equality -> equality EQ rel
Rule 48    equality -> equality NE rel
Rule 49    equality -> rel
Rule 50    rel -> expr LT expr
Rule 51    rel -> expr LE expr
Rule 52    rel -> expr GT expr
Rule 53    rel -> expr GE expr
Rule 54    rel -> expr
Rule 55    if -> IF LPAREN condition RPAREN LBRACE statements RBRACE
Rule 56    if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else
Rule 57    else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE
Rule 58    else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else
Rule 59    else -> ELSE LBRACE statements RBRACE
Rule 60    while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE
Rule 61    for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
Rule 62    break -> BREAK
Rule 63    function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE
Rule 64    function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE
Rule 65    args -> args COMMA ID
Rule 66    args -> ID
Rule 67    call -> ID LPAREN exprs RPAREN
Rule 68    call -> ID LPAREN RPAREN
Rule 69    call -> ID DOT ID LPAREN exprs RPAREN
Rule 70    call -> ID DOT ID LPAREN RPAREN
Rule 71    return -> RETURN
Rule 72    return -> RETURN exprs
Rule 73    class -> CLASS ID LBRACE functions RBRACE
Rule 74    functions -> functions function
Rule 75    functions -> function
Rule 76    string -> STRING

Terminals, with rules where they appear

AND                  : 45
ASSIGN               : 14
BREAK                : 62
CLASS                : 73
COMMA                : 36 65
DEF                  : 63 64
DIVIDE               : 28
DMINUS               : 18
DOT                  : 20 69 70
DPLUS                : 17
EDIVIDE              : 29
ELIF                 : 57 58
ELSE                 : 59
EQ                   : 47
FOR                  : 61
GE                   : 53
GT                   : 52
ID                   : 20 20 21 63 64 65 66 67 68 69 69 70 70 73
IF                   : 55 56
LBRACE               : 55 56 57 58 59 60 61 63 64 73
LBRACKET             : 19 41 42
LE                   : 51
LEN                  : 38
LPAREN               : 35 38 39 40 55 56 57 58 60 61 63 64 67 68 69 70
LT                   : 50
MINEQUAL             : 15
MINUS                : 23
NE                   : 48
NUMBER               : 32
OR                   : 43
PLUS                 : 22
PLUSEQUAL            : 16
PRINT                : 39 40
RBRACE               : 55 56 57 58 59 60 61 63 64 73
RBRACKET             : 19 41 42
RETURN               : 71 72
RPAREN               : 35 38 39 40 55 56 57 58 60 61 63 64 67 68 69 70
SEMICOLON            : 61 61
STRING               : 76
TIMES                : 27
WHILE                : 60
error                : 

Nonterminals, with rules where they appear

args                 : 63 65
array                : 26
assignment           : 4 61 61
break                : 10
call                 : 34
class                : 12
condition            : 43 55 56 57 58 60 61
else                 : 56 58
equality             : 45 46 47 48
expr                 : 5 14 15 16 19 22 23 35 36 37 50 50 51 51 52 52 53 53 54
exprs                : 36 39 41 67 69 72
factor               : 27 28 29 30
for                  : 9
function             : 11 74 75
functions            : 73 74
if                   : 7
join                 : 43 44 45
len                  : 33
print                : 6
program              : 0
rel                  : 47 48 49
return               : 13
statement            : 2 3
statements           : 1 2 55 56 57 58 59 60 61 63 64
string               : 25
term                 : 22 23 24 27 28 29
variable             : 14 15 16 17 18 19 31 38
while                : 8

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    $end            reduce using rule 1 (program -> statements .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statement                      shift and go to state 35
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 3

    (3) statements -> statement .

    PRINT           reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    BREAK           reduce using rule 3 (statements -> statement .)
    DEF             reduce using rule 3 (statements -> statement .)
    CLASS           reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    ID              reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    LBRACKET        reduce using rule 3 (statements -> statement .)
    NUMBER          reduce using rule 3 (statements -> statement .)
    LPAREN          reduce using rule 3 (statements -> statement .)
    LEN             reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)
    RBRACE          reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> assignment .

    PRINT           reduce using rule 4 (statement -> assignment .)
    IF              reduce using rule 4 (statement -> assignment .)
    WHILE           reduce using rule 4 (statement -> assignment .)
    FOR             reduce using rule 4 (statement -> assignment .)
    BREAK           reduce using rule 4 (statement -> assignment .)
    DEF             reduce using rule 4 (statement -> assignment .)
    CLASS           reduce using rule 4 (statement -> assignment .)
    RETURN          reduce using rule 4 (statement -> assignment .)
    ID              reduce using rule 4 (statement -> assignment .)
    STRING          reduce using rule 4 (statement -> assignment .)
    LBRACKET        reduce using rule 4 (statement -> assignment .)
    NUMBER          reduce using rule 4 (statement -> assignment .)
    LPAREN          reduce using rule 4 (statement -> assignment .)
    LEN             reduce using rule 4 (statement -> assignment .)
    $end            reduce using rule 4 (statement -> assignment .)
    RBRACE          reduce using rule 4 (statement -> assignment .)


state 5

    (5) statement -> expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    PRINT           reduce using rule 5 (statement -> expr .)
    IF              reduce using rule 5 (statement -> expr .)
    WHILE           reduce using rule 5 (statement -> expr .)
    FOR             reduce using rule 5 (statement -> expr .)
    BREAK           reduce using rule 5 (statement -> expr .)
    DEF             reduce using rule 5 (statement -> expr .)
    CLASS           reduce using rule 5 (statement -> expr .)
    RETURN          reduce using rule 5 (statement -> expr .)
    ID              reduce using rule 5 (statement -> expr .)
    STRING          reduce using rule 5 (statement -> expr .)
    LBRACKET        reduce using rule 5 (statement -> expr .)
    NUMBER          reduce using rule 5 (statement -> expr .)
    LPAREN          reduce using rule 5 (statement -> expr .)
    LEN             reduce using rule 5 (statement -> expr .)
    $end            reduce using rule 5 (statement -> expr .)
    RBRACE          reduce using rule 5 (statement -> expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 6

    (6) statement -> print .

    PRINT           reduce using rule 6 (statement -> print .)
    IF              reduce using rule 6 (statement -> print .)
    WHILE           reduce using rule 6 (statement -> print .)
    FOR             reduce using rule 6 (statement -> print .)
    BREAK           reduce using rule 6 (statement -> print .)
    DEF             reduce using rule 6 (statement -> print .)
    CLASS           reduce using rule 6 (statement -> print .)
    RETURN          reduce using rule 6 (statement -> print .)
    ID              reduce using rule 6 (statement -> print .)
    STRING          reduce using rule 6 (statement -> print .)
    LBRACKET        reduce using rule 6 (statement -> print .)
    NUMBER          reduce using rule 6 (statement -> print .)
    LPAREN          reduce using rule 6 (statement -> print .)
    LEN             reduce using rule 6 (statement -> print .)
    $end            reduce using rule 6 (statement -> print .)
    RBRACE          reduce using rule 6 (statement -> print .)


state 7

    (7) statement -> if .

    PRINT           reduce using rule 7 (statement -> if .)
    IF              reduce using rule 7 (statement -> if .)
    WHILE           reduce using rule 7 (statement -> if .)
    FOR             reduce using rule 7 (statement -> if .)
    BREAK           reduce using rule 7 (statement -> if .)
    DEF             reduce using rule 7 (statement -> if .)
    CLASS           reduce using rule 7 (statement -> if .)
    RETURN          reduce using rule 7 (statement -> if .)
    ID              reduce using rule 7 (statement -> if .)
    STRING          reduce using rule 7 (statement -> if .)
    LBRACKET        reduce using rule 7 (statement -> if .)
    NUMBER          reduce using rule 7 (statement -> if .)
    LPAREN          reduce using rule 7 (statement -> if .)
    LEN             reduce using rule 7 (statement -> if .)
    $end            reduce using rule 7 (statement -> if .)
    RBRACE          reduce using rule 7 (statement -> if .)


state 8

    (8) statement -> while .

    PRINT           reduce using rule 8 (statement -> while .)
    IF              reduce using rule 8 (statement -> while .)
    WHILE           reduce using rule 8 (statement -> while .)
    FOR             reduce using rule 8 (statement -> while .)
    BREAK           reduce using rule 8 (statement -> while .)
    DEF             reduce using rule 8 (statement -> while .)
    CLASS           reduce using rule 8 (statement -> while .)
    RETURN          reduce using rule 8 (statement -> while .)
    ID              reduce using rule 8 (statement -> while .)
    STRING          reduce using rule 8 (statement -> while .)
    LBRACKET        reduce using rule 8 (statement -> while .)
    NUMBER          reduce using rule 8 (statement -> while .)
    LPAREN          reduce using rule 8 (statement -> while .)
    LEN             reduce using rule 8 (statement -> while .)
    $end            reduce using rule 8 (statement -> while .)
    RBRACE          reduce using rule 8 (statement -> while .)


state 9

    (9) statement -> for .

    PRINT           reduce using rule 9 (statement -> for .)
    IF              reduce using rule 9 (statement -> for .)
    WHILE           reduce using rule 9 (statement -> for .)
    FOR             reduce using rule 9 (statement -> for .)
    BREAK           reduce using rule 9 (statement -> for .)
    DEF             reduce using rule 9 (statement -> for .)
    CLASS           reduce using rule 9 (statement -> for .)
    RETURN          reduce using rule 9 (statement -> for .)
    ID              reduce using rule 9 (statement -> for .)
    STRING          reduce using rule 9 (statement -> for .)
    LBRACKET        reduce using rule 9 (statement -> for .)
    NUMBER          reduce using rule 9 (statement -> for .)
    LPAREN          reduce using rule 9 (statement -> for .)
    LEN             reduce using rule 9 (statement -> for .)
    $end            reduce using rule 9 (statement -> for .)
    RBRACE          reduce using rule 9 (statement -> for .)


state 10

    (10) statement -> break .

    PRINT           reduce using rule 10 (statement -> break .)
    IF              reduce using rule 10 (statement -> break .)
    WHILE           reduce using rule 10 (statement -> break .)
    FOR             reduce using rule 10 (statement -> break .)
    BREAK           reduce using rule 10 (statement -> break .)
    DEF             reduce using rule 10 (statement -> break .)
    CLASS           reduce using rule 10 (statement -> break .)
    RETURN          reduce using rule 10 (statement -> break .)
    ID              reduce using rule 10 (statement -> break .)
    STRING          reduce using rule 10 (statement -> break .)
    LBRACKET        reduce using rule 10 (statement -> break .)
    NUMBER          reduce using rule 10 (statement -> break .)
    LPAREN          reduce using rule 10 (statement -> break .)
    LEN             reduce using rule 10 (statement -> break .)
    $end            reduce using rule 10 (statement -> break .)
    RBRACE          reduce using rule 10 (statement -> break .)


state 11

    (11) statement -> function .

    PRINT           reduce using rule 11 (statement -> function .)
    IF              reduce using rule 11 (statement -> function .)
    WHILE           reduce using rule 11 (statement -> function .)
    FOR             reduce using rule 11 (statement -> function .)
    BREAK           reduce using rule 11 (statement -> function .)
    DEF             reduce using rule 11 (statement -> function .)
    CLASS           reduce using rule 11 (statement -> function .)
    RETURN          reduce using rule 11 (statement -> function .)
    ID              reduce using rule 11 (statement -> function .)
    STRING          reduce using rule 11 (statement -> function .)
    LBRACKET        reduce using rule 11 (statement -> function .)
    NUMBER          reduce using rule 11 (statement -> function .)
    LPAREN          reduce using rule 11 (statement -> function .)
    LEN             reduce using rule 11 (statement -> function .)
    $end            reduce using rule 11 (statement -> function .)
    RBRACE          reduce using rule 11 (statement -> function .)


state 12

    (12) statement -> class .

    PRINT           reduce using rule 12 (statement -> class .)
    IF              reduce using rule 12 (statement -> class .)
    WHILE           reduce using rule 12 (statement -> class .)
    FOR             reduce using rule 12 (statement -> class .)
    BREAK           reduce using rule 12 (statement -> class .)
    DEF             reduce using rule 12 (statement -> class .)
    CLASS           reduce using rule 12 (statement -> class .)
    RETURN          reduce using rule 12 (statement -> class .)
    ID              reduce using rule 12 (statement -> class .)
    STRING          reduce using rule 12 (statement -> class .)
    LBRACKET        reduce using rule 12 (statement -> class .)
    NUMBER          reduce using rule 12 (statement -> class .)
    LPAREN          reduce using rule 12 (statement -> class .)
    LEN             reduce using rule 12 (statement -> class .)
    $end            reduce using rule 12 (statement -> class .)
    RBRACE          reduce using rule 12 (statement -> class .)


state 13

    (13) statement -> return .

    PRINT           reduce using rule 13 (statement -> return .)
    IF              reduce using rule 13 (statement -> return .)
    WHILE           reduce using rule 13 (statement -> return .)
    FOR             reduce using rule 13 (statement -> return .)
    BREAK           reduce using rule 13 (statement -> return .)
    DEF             reduce using rule 13 (statement -> return .)
    CLASS           reduce using rule 13 (statement -> return .)
    RETURN          reduce using rule 13 (statement -> return .)
    ID              reduce using rule 13 (statement -> return .)
    STRING          reduce using rule 13 (statement -> return .)
    LBRACKET        reduce using rule 13 (statement -> return .)
    NUMBER          reduce using rule 13 (statement -> return .)
    LPAREN          reduce using rule 13 (statement -> return .)
    LEN             reduce using rule 13 (statement -> return .)
    $end            reduce using rule 13 (statement -> return .)
    RBRACE          reduce using rule 13 (statement -> return .)


state 14

    (14) assignment -> variable . ASSIGN expr
    (15) assignment -> variable . MINEQUAL expr
    (16) assignment -> variable . PLUSEQUAL expr
    (17) assignment -> variable . DPLUS
    (18) assignment -> variable . DMINUS
    (19) variable -> variable . LBRACKET expr RBRACKET
    (31) factor -> variable .

  ! shift/reduce conflict for LBRACKET resolved as shift
    ASSIGN          shift and go to state 38
    MINEQUAL        shift and go to state 39
    PLUSEQUAL       shift and go to state 40
    DPLUS           shift and go to state 41
    DMINUS          shift and go to state 42
    LBRACKET        shift and go to state 43
    TIMES           reduce using rule 31 (factor -> variable .)
    DIVIDE          reduce using rule 31 (factor -> variable .)
    EDIVIDE         reduce using rule 31 (factor -> variable .)
    PLUS            reduce using rule 31 (factor -> variable .)
    MINUS           reduce using rule 31 (factor -> variable .)
    PRINT           reduce using rule 31 (factor -> variable .)
    IF              reduce using rule 31 (factor -> variable .)
    WHILE           reduce using rule 31 (factor -> variable .)
    FOR             reduce using rule 31 (factor -> variable .)
    BREAK           reduce using rule 31 (factor -> variable .)
    DEF             reduce using rule 31 (factor -> variable .)
    CLASS           reduce using rule 31 (factor -> variable .)
    RETURN          reduce using rule 31 (factor -> variable .)
    ID              reduce using rule 31 (factor -> variable .)
    STRING          reduce using rule 31 (factor -> variable .)
    NUMBER          reduce using rule 31 (factor -> variable .)
    LPAREN          reduce using rule 31 (factor -> variable .)
    LEN             reduce using rule 31 (factor -> variable .)
    $end            reduce using rule 31 (factor -> variable .)
    RBRACE          reduce using rule 31 (factor -> variable .)

  ! LBRACKET        [ reduce using rule 31 (factor -> variable .) ]


state 15

    (24) expr -> term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor
    (29) term -> term . EDIVIDE factor

    PLUS            reduce using rule 24 (expr -> term .)
    MINUS           reduce using rule 24 (expr -> term .)
    PRINT           reduce using rule 24 (expr -> term .)
    IF              reduce using rule 24 (expr -> term .)
    WHILE           reduce using rule 24 (expr -> term .)
    FOR             reduce using rule 24 (expr -> term .)
    BREAK           reduce using rule 24 (expr -> term .)
    DEF             reduce using rule 24 (expr -> term .)
    CLASS           reduce using rule 24 (expr -> term .)
    RETURN          reduce using rule 24 (expr -> term .)
    ID              reduce using rule 24 (expr -> term .)
    STRING          reduce using rule 24 (expr -> term .)
    LBRACKET        reduce using rule 24 (expr -> term .)
    NUMBER          reduce using rule 24 (expr -> term .)
    LPAREN          reduce using rule 24 (expr -> term .)
    LEN             reduce using rule 24 (expr -> term .)
    $end            reduce using rule 24 (expr -> term .)
    RPAREN          reduce using rule 24 (expr -> term .)
    COMMA           reduce using rule 24 (expr -> term .)
    RBRACE          reduce using rule 24 (expr -> term .)
    RBRACKET        reduce using rule 24 (expr -> term .)
    SEMICOLON       reduce using rule 24 (expr -> term .)
    LT              reduce using rule 24 (expr -> term .)
    LE              reduce using rule 24 (expr -> term .)
    GT              reduce using rule 24 (expr -> term .)
    GE              reduce using rule 24 (expr -> term .)
    EQ              reduce using rule 24 (expr -> term .)
    NE              reduce using rule 24 (expr -> term .)
    AND             reduce using rule 24 (expr -> term .)
    OR              reduce using rule 24 (expr -> term .)
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    EDIVIDE         shift and go to state 46


state 16

    (25) expr -> string .

    PLUS            reduce using rule 25 (expr -> string .)
    MINUS           reduce using rule 25 (expr -> string .)
    PRINT           reduce using rule 25 (expr -> string .)
    IF              reduce using rule 25 (expr -> string .)
    WHILE           reduce using rule 25 (expr -> string .)
    FOR             reduce using rule 25 (expr -> string .)
    BREAK           reduce using rule 25 (expr -> string .)
    DEF             reduce using rule 25 (expr -> string .)
    CLASS           reduce using rule 25 (expr -> string .)
    RETURN          reduce using rule 25 (expr -> string .)
    ID              reduce using rule 25 (expr -> string .)
    STRING          reduce using rule 25 (expr -> string .)
    LBRACKET        reduce using rule 25 (expr -> string .)
    NUMBER          reduce using rule 25 (expr -> string .)
    LPAREN          reduce using rule 25 (expr -> string .)
    LEN             reduce using rule 25 (expr -> string .)
    $end            reduce using rule 25 (expr -> string .)
    RPAREN          reduce using rule 25 (expr -> string .)
    COMMA           reduce using rule 25 (expr -> string .)
    RBRACE          reduce using rule 25 (expr -> string .)
    RBRACKET        reduce using rule 25 (expr -> string .)
    SEMICOLON       reduce using rule 25 (expr -> string .)
    LT              reduce using rule 25 (expr -> string .)
    LE              reduce using rule 25 (expr -> string .)
    GT              reduce using rule 25 (expr -> string .)
    GE              reduce using rule 25 (expr -> string .)
    EQ              reduce using rule 25 (expr -> string .)
    NE              reduce using rule 25 (expr -> string .)
    AND             reduce using rule 25 (expr -> string .)
    OR              reduce using rule 25 (expr -> string .)


state 17

    (26) expr -> array .

    PLUS            reduce using rule 26 (expr -> array .)
    MINUS           reduce using rule 26 (expr -> array .)
    PRINT           reduce using rule 26 (expr -> array .)
    IF              reduce using rule 26 (expr -> array .)
    WHILE           reduce using rule 26 (expr -> array .)
    FOR             reduce using rule 26 (expr -> array .)
    BREAK           reduce using rule 26 (expr -> array .)
    DEF             reduce using rule 26 (expr -> array .)
    CLASS           reduce using rule 26 (expr -> array .)
    RETURN          reduce using rule 26 (expr -> array .)
    ID              reduce using rule 26 (expr -> array .)
    STRING          reduce using rule 26 (expr -> array .)
    LBRACKET        reduce using rule 26 (expr -> array .)
    NUMBER          reduce using rule 26 (expr -> array .)
    LPAREN          reduce using rule 26 (expr -> array .)
    LEN             reduce using rule 26 (expr -> array .)
    $end            reduce using rule 26 (expr -> array .)
    RPAREN          reduce using rule 26 (expr -> array .)
    COMMA           reduce using rule 26 (expr -> array .)
    RBRACE          reduce using rule 26 (expr -> array .)
    RBRACKET        reduce using rule 26 (expr -> array .)
    SEMICOLON       reduce using rule 26 (expr -> array .)
    LT              reduce using rule 26 (expr -> array .)
    LE              reduce using rule 26 (expr -> array .)
    GT              reduce using rule 26 (expr -> array .)
    GE              reduce using rule 26 (expr -> array .)
    EQ              reduce using rule 26 (expr -> array .)
    NE              reduce using rule 26 (expr -> array .)
    AND             reduce using rule 26 (expr -> array .)
    OR              reduce using rule 26 (expr -> array .)


state 18

    (39) print -> PRINT . LPAREN exprs RPAREN
    (40) print -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 47


state 19

    (35) factor -> LPAREN . expr RPAREN
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    expr                           shift and go to state 48
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 20

    (55) if -> IF . LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> IF . LPAREN condition RPAREN LBRACE statements RBRACE else

    LPAREN          shift and go to state 50


state 21

    (60) while -> WHILE . LPAREN condition RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 51


state 22

    (61) for -> FOR . LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 52


state 23

    (62) break -> BREAK .

    PRINT           reduce using rule 62 (break -> BREAK .)
    IF              reduce using rule 62 (break -> BREAK .)
    WHILE           reduce using rule 62 (break -> BREAK .)
    FOR             reduce using rule 62 (break -> BREAK .)
    BREAK           reduce using rule 62 (break -> BREAK .)
    DEF             reduce using rule 62 (break -> BREAK .)
    CLASS           reduce using rule 62 (break -> BREAK .)
    RETURN          reduce using rule 62 (break -> BREAK .)
    ID              reduce using rule 62 (break -> BREAK .)
    STRING          reduce using rule 62 (break -> BREAK .)
    LBRACKET        reduce using rule 62 (break -> BREAK .)
    NUMBER          reduce using rule 62 (break -> BREAK .)
    LPAREN          reduce using rule 62 (break -> BREAK .)
    LEN             reduce using rule 62 (break -> BREAK .)
    $end            reduce using rule 62 (break -> BREAK .)
    RBRACE          reduce using rule 62 (break -> BREAK .)


state 24

    (63) function -> DEF . ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> DEF . ID LPAREN RPAREN LBRACE statements RBRACE

    ID              shift and go to state 53


state 25

    (20) variable -> ID . DOT ID
    (21) variable -> ID .
    (67) call -> ID . LPAREN exprs RPAREN
    (68) call -> ID . LPAREN RPAREN
    (69) call -> ID . DOT ID LPAREN exprs RPAREN
    (70) call -> ID . DOT ID LPAREN RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    DOT             shift and go to state 54
    ASSIGN          reduce using rule 21 (variable -> ID .)
    MINEQUAL        reduce using rule 21 (variable -> ID .)
    PLUSEQUAL       reduce using rule 21 (variable -> ID .)
    DPLUS           reduce using rule 21 (variable -> ID .)
    DMINUS          reduce using rule 21 (variable -> ID .)
    LBRACKET        reduce using rule 21 (variable -> ID .)
    TIMES           reduce using rule 21 (variable -> ID .)
    DIVIDE          reduce using rule 21 (variable -> ID .)
    EDIVIDE         reduce using rule 21 (variable -> ID .)
    PLUS            reduce using rule 21 (variable -> ID .)
    MINUS           reduce using rule 21 (variable -> ID .)
    PRINT           reduce using rule 21 (variable -> ID .)
    IF              reduce using rule 21 (variable -> ID .)
    WHILE           reduce using rule 21 (variable -> ID .)
    FOR             reduce using rule 21 (variable -> ID .)
    BREAK           reduce using rule 21 (variable -> ID .)
    DEF             reduce using rule 21 (variable -> ID .)
    CLASS           reduce using rule 21 (variable -> ID .)
    RETURN          reduce using rule 21 (variable -> ID .)
    ID              reduce using rule 21 (variable -> ID .)
    STRING          reduce using rule 21 (variable -> ID .)
    NUMBER          reduce using rule 21 (variable -> ID .)
    LEN             reduce using rule 21 (variable -> ID .)
    $end            reduce using rule 21 (variable -> ID .)
    RPAREN          reduce using rule 21 (variable -> ID .)
    COMMA           reduce using rule 21 (variable -> ID .)
    RBRACE          reduce using rule 21 (variable -> ID .)
    RBRACKET        reduce using rule 21 (variable -> ID .)
    SEMICOLON       reduce using rule 21 (variable -> ID .)
    LT              reduce using rule 21 (variable -> ID .)
    LE              reduce using rule 21 (variable -> ID .)
    GT              reduce using rule 21 (variable -> ID .)
    GE              reduce using rule 21 (variable -> ID .)
    EQ              reduce using rule 21 (variable -> ID .)
    NE              reduce using rule 21 (variable -> ID .)
    AND             reduce using rule 21 (variable -> ID .)
    OR              reduce using rule 21 (variable -> ID .)
    LPAREN          shift and go to state 55

  ! LPAREN          [ reduce using rule 21 (variable -> ID .) ]


state 26

    (73) class -> CLASS . ID LBRACE functions RBRACE

    ID              shift and go to state 56


state 27

    (71) return -> RETURN .
    (72) return -> RETURN . exprs
    (36) exprs -> . exprs COMMA expr
    (37) exprs -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LEN resolved as shift
    PRINT           reduce using rule 71 (return -> RETURN .)
    IF              reduce using rule 71 (return -> RETURN .)
    WHILE           reduce using rule 71 (return -> RETURN .)
    FOR             reduce using rule 71 (return -> RETURN .)
    BREAK           reduce using rule 71 (return -> RETURN .)
    DEF             reduce using rule 71 (return -> RETURN .)
    CLASS           reduce using rule 71 (return -> RETURN .)
    RETURN          reduce using rule 71 (return -> RETURN .)
    $end            reduce using rule 71 (return -> RETURN .)
    RBRACE          reduce using rule 71 (return -> RETURN .)
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

  ! ID              [ reduce using rule 71 (return -> RETURN .) ]
  ! STRING          [ reduce using rule 71 (return -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 71 (return -> RETURN .) ]
  ! NUMBER          [ reduce using rule 71 (return -> RETURN .) ]
  ! LPAREN          [ reduce using rule 71 (return -> RETURN .) ]
  ! LEN             [ reduce using rule 71 (return -> RETURN .) ]

    exprs                          shift and go to state 57
    expr                           shift and go to state 58
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 28

    (41) array -> LBRACKET . exprs RBRACKET
    (42) array -> LBRACKET . RBRACKET
    (36) exprs -> . exprs COMMA expr
    (37) exprs -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACKET        shift and go to state 60
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    exprs                          shift and go to state 59
    expr                           shift and go to state 58
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 29

    (30) term -> factor .

    TIMES           reduce using rule 30 (term -> factor .)
    DIVIDE          reduce using rule 30 (term -> factor .)
    EDIVIDE         reduce using rule 30 (term -> factor .)
    PLUS            reduce using rule 30 (term -> factor .)
    MINUS           reduce using rule 30 (term -> factor .)
    PRINT           reduce using rule 30 (term -> factor .)
    IF              reduce using rule 30 (term -> factor .)
    WHILE           reduce using rule 30 (term -> factor .)
    FOR             reduce using rule 30 (term -> factor .)
    BREAK           reduce using rule 30 (term -> factor .)
    DEF             reduce using rule 30 (term -> factor .)
    CLASS           reduce using rule 30 (term -> factor .)
    RETURN          reduce using rule 30 (term -> factor .)
    ID              reduce using rule 30 (term -> factor .)
    STRING          reduce using rule 30 (term -> factor .)
    LBRACKET        reduce using rule 30 (term -> factor .)
    NUMBER          reduce using rule 30 (term -> factor .)
    LPAREN          reduce using rule 30 (term -> factor .)
    LEN             reduce using rule 30 (term -> factor .)
    $end            reduce using rule 30 (term -> factor .)
    RPAREN          reduce using rule 30 (term -> factor .)
    COMMA           reduce using rule 30 (term -> factor .)
    RBRACE          reduce using rule 30 (term -> factor .)
    RBRACKET        reduce using rule 30 (term -> factor .)
    SEMICOLON       reduce using rule 30 (term -> factor .)
    LT              reduce using rule 30 (term -> factor .)
    LE              reduce using rule 30 (term -> factor .)
    GT              reduce using rule 30 (term -> factor .)
    GE              reduce using rule 30 (term -> factor .)
    EQ              reduce using rule 30 (term -> factor .)
    NE              reduce using rule 30 (term -> factor .)
    AND             reduce using rule 30 (term -> factor .)
    OR              reduce using rule 30 (term -> factor .)


state 30

    (76) string -> STRING .

    PLUS            reduce using rule 76 (string -> STRING .)
    MINUS           reduce using rule 76 (string -> STRING .)
    PRINT           reduce using rule 76 (string -> STRING .)
    IF              reduce using rule 76 (string -> STRING .)
    WHILE           reduce using rule 76 (string -> STRING .)
    FOR             reduce using rule 76 (string -> STRING .)
    BREAK           reduce using rule 76 (string -> STRING .)
    DEF             reduce using rule 76 (string -> STRING .)
    CLASS           reduce using rule 76 (string -> STRING .)
    RETURN          reduce using rule 76 (string -> STRING .)
    ID              reduce using rule 76 (string -> STRING .)
    STRING          reduce using rule 76 (string -> STRING .)
    LBRACKET        reduce using rule 76 (string -> STRING .)
    NUMBER          reduce using rule 76 (string -> STRING .)
    LPAREN          reduce using rule 76 (string -> STRING .)
    LEN             reduce using rule 76 (string -> STRING .)
    $end            reduce using rule 76 (string -> STRING .)
    RPAREN          reduce using rule 76 (string -> STRING .)
    COMMA           reduce using rule 76 (string -> STRING .)
    RBRACE          reduce using rule 76 (string -> STRING .)
    RBRACKET        reduce using rule 76 (string -> STRING .)
    SEMICOLON       reduce using rule 76 (string -> STRING .)
    LT              reduce using rule 76 (string -> STRING .)
    LE              reduce using rule 76 (string -> STRING .)
    GT              reduce using rule 76 (string -> STRING .)
    GE              reduce using rule 76 (string -> STRING .)
    EQ              reduce using rule 76 (string -> STRING .)
    NE              reduce using rule 76 (string -> STRING .)
    AND             reduce using rule 76 (string -> STRING .)
    OR              reduce using rule 76 (string -> STRING .)


state 31

    (32) factor -> NUMBER .

    TIMES           reduce using rule 32 (factor -> NUMBER .)
    DIVIDE          reduce using rule 32 (factor -> NUMBER .)
    EDIVIDE         reduce using rule 32 (factor -> NUMBER .)
    PLUS            reduce using rule 32 (factor -> NUMBER .)
    MINUS           reduce using rule 32 (factor -> NUMBER .)
    PRINT           reduce using rule 32 (factor -> NUMBER .)
    IF              reduce using rule 32 (factor -> NUMBER .)
    WHILE           reduce using rule 32 (factor -> NUMBER .)
    FOR             reduce using rule 32 (factor -> NUMBER .)
    BREAK           reduce using rule 32 (factor -> NUMBER .)
    DEF             reduce using rule 32 (factor -> NUMBER .)
    CLASS           reduce using rule 32 (factor -> NUMBER .)
    RETURN          reduce using rule 32 (factor -> NUMBER .)
    ID              reduce using rule 32 (factor -> NUMBER .)
    STRING          reduce using rule 32 (factor -> NUMBER .)
    LBRACKET        reduce using rule 32 (factor -> NUMBER .)
    NUMBER          reduce using rule 32 (factor -> NUMBER .)
    LPAREN          reduce using rule 32 (factor -> NUMBER .)
    LEN             reduce using rule 32 (factor -> NUMBER .)
    $end            reduce using rule 32 (factor -> NUMBER .)
    RPAREN          reduce using rule 32 (factor -> NUMBER .)
    COMMA           reduce using rule 32 (factor -> NUMBER .)
    RBRACE          reduce using rule 32 (factor -> NUMBER .)
    RBRACKET        reduce using rule 32 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 32 (factor -> NUMBER .)
    LT              reduce using rule 32 (factor -> NUMBER .)
    LE              reduce using rule 32 (factor -> NUMBER .)
    GT              reduce using rule 32 (factor -> NUMBER .)
    GE              reduce using rule 32 (factor -> NUMBER .)
    EQ              reduce using rule 32 (factor -> NUMBER .)
    NE              reduce using rule 32 (factor -> NUMBER .)
    AND             reduce using rule 32 (factor -> NUMBER .)
    OR              reduce using rule 32 (factor -> NUMBER .)


state 32

    (33) factor -> len .

    TIMES           reduce using rule 33 (factor -> len .)
    DIVIDE          reduce using rule 33 (factor -> len .)
    EDIVIDE         reduce using rule 33 (factor -> len .)
    PLUS            reduce using rule 33 (factor -> len .)
    MINUS           reduce using rule 33 (factor -> len .)
    PRINT           reduce using rule 33 (factor -> len .)
    IF              reduce using rule 33 (factor -> len .)
    WHILE           reduce using rule 33 (factor -> len .)
    FOR             reduce using rule 33 (factor -> len .)
    BREAK           reduce using rule 33 (factor -> len .)
    DEF             reduce using rule 33 (factor -> len .)
    CLASS           reduce using rule 33 (factor -> len .)
    RETURN          reduce using rule 33 (factor -> len .)
    ID              reduce using rule 33 (factor -> len .)
    STRING          reduce using rule 33 (factor -> len .)
    LBRACKET        reduce using rule 33 (factor -> len .)
    NUMBER          reduce using rule 33 (factor -> len .)
    LPAREN          reduce using rule 33 (factor -> len .)
    LEN             reduce using rule 33 (factor -> len .)
    $end            reduce using rule 33 (factor -> len .)
    RPAREN          reduce using rule 33 (factor -> len .)
    COMMA           reduce using rule 33 (factor -> len .)
    RBRACE          reduce using rule 33 (factor -> len .)
    RBRACKET        reduce using rule 33 (factor -> len .)
    SEMICOLON       reduce using rule 33 (factor -> len .)
    LT              reduce using rule 33 (factor -> len .)
    LE              reduce using rule 33 (factor -> len .)
    GT              reduce using rule 33 (factor -> len .)
    GE              reduce using rule 33 (factor -> len .)
    EQ              reduce using rule 33 (factor -> len .)
    NE              reduce using rule 33 (factor -> len .)
    AND             reduce using rule 33 (factor -> len .)
    OR              reduce using rule 33 (factor -> len .)


state 33

    (34) factor -> call .

    TIMES           reduce using rule 34 (factor -> call .)
    DIVIDE          reduce using rule 34 (factor -> call .)
    EDIVIDE         reduce using rule 34 (factor -> call .)
    PLUS            reduce using rule 34 (factor -> call .)
    MINUS           reduce using rule 34 (factor -> call .)
    PRINT           reduce using rule 34 (factor -> call .)
    IF              reduce using rule 34 (factor -> call .)
    WHILE           reduce using rule 34 (factor -> call .)
    FOR             reduce using rule 34 (factor -> call .)
    BREAK           reduce using rule 34 (factor -> call .)
    DEF             reduce using rule 34 (factor -> call .)
    CLASS           reduce using rule 34 (factor -> call .)
    RETURN          reduce using rule 34 (factor -> call .)
    ID              reduce using rule 34 (factor -> call .)
    STRING          reduce using rule 34 (factor -> call .)
    LBRACKET        reduce using rule 34 (factor -> call .)
    NUMBER          reduce using rule 34 (factor -> call .)
    LPAREN          reduce using rule 34 (factor -> call .)
    LEN             reduce using rule 34 (factor -> call .)
    $end            reduce using rule 34 (factor -> call .)
    RPAREN          reduce using rule 34 (factor -> call .)
    COMMA           reduce using rule 34 (factor -> call .)
    RBRACE          reduce using rule 34 (factor -> call .)
    RBRACKET        reduce using rule 34 (factor -> call .)
    SEMICOLON       reduce using rule 34 (factor -> call .)
    LT              reduce using rule 34 (factor -> call .)
    LE              reduce using rule 34 (factor -> call .)
    GT              reduce using rule 34 (factor -> call .)
    GE              reduce using rule 34 (factor -> call .)
    EQ              reduce using rule 34 (factor -> call .)
    NE              reduce using rule 34 (factor -> call .)
    AND             reduce using rule 34 (factor -> call .)
    OR              reduce using rule 34 (factor -> call .)


state 34

    (38) len -> LEN . LPAREN variable RPAREN

    LPAREN          shift and go to state 61


state 35

    (2) statements -> statements statement .

    PRINT           reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    WHILE           reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    BREAK           reduce using rule 2 (statements -> statements statement .)
    DEF             reduce using rule 2 (statements -> statements statement .)
    CLASS           reduce using rule 2 (statements -> statements statement .)
    RETURN          reduce using rule 2 (statements -> statements statement .)
    ID              reduce using rule 2 (statements -> statements statement .)
    STRING          reduce using rule 2 (statements -> statements statement .)
    LBRACKET        reduce using rule 2 (statements -> statements statement .)
    NUMBER          reduce using rule 2 (statements -> statements statement .)
    LPAREN          reduce using rule 2 (statements -> statements statement .)
    LEN             reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)
    RBRACE          reduce using rule 2 (statements -> statements statement .)


state 36

    (22) expr -> expr PLUS . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    term                           shift and go to state 62
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 37

    (23) expr -> expr MINUS . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    term                           shift and go to state 63
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 38

    (14) assignment -> variable ASSIGN . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    variable                       shift and go to state 49
    expr                           shift and go to state 64
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 39

    (15) assignment -> variable MINEQUAL . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    variable                       shift and go to state 49
    expr                           shift and go to state 65
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 40

    (16) assignment -> variable PLUSEQUAL . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    variable                       shift and go to state 49
    expr                           shift and go to state 66
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 41

    (17) assignment -> variable DPLUS .

    PRINT           reduce using rule 17 (assignment -> variable DPLUS .)
    IF              reduce using rule 17 (assignment -> variable DPLUS .)
    WHILE           reduce using rule 17 (assignment -> variable DPLUS .)
    FOR             reduce using rule 17 (assignment -> variable DPLUS .)
    BREAK           reduce using rule 17 (assignment -> variable DPLUS .)
    DEF             reduce using rule 17 (assignment -> variable DPLUS .)
    CLASS           reduce using rule 17 (assignment -> variable DPLUS .)
    RETURN          reduce using rule 17 (assignment -> variable DPLUS .)
    ID              reduce using rule 17 (assignment -> variable DPLUS .)
    STRING          reduce using rule 17 (assignment -> variable DPLUS .)
    LBRACKET        reduce using rule 17 (assignment -> variable DPLUS .)
    NUMBER          reduce using rule 17 (assignment -> variable DPLUS .)
    LPAREN          reduce using rule 17 (assignment -> variable DPLUS .)
    LEN             reduce using rule 17 (assignment -> variable DPLUS .)
    $end            reduce using rule 17 (assignment -> variable DPLUS .)
    SEMICOLON       reduce using rule 17 (assignment -> variable DPLUS .)
    RBRACE          reduce using rule 17 (assignment -> variable DPLUS .)
    RPAREN          reduce using rule 17 (assignment -> variable DPLUS .)


state 42

    (18) assignment -> variable DMINUS .

    PRINT           reduce using rule 18 (assignment -> variable DMINUS .)
    IF              reduce using rule 18 (assignment -> variable DMINUS .)
    WHILE           reduce using rule 18 (assignment -> variable DMINUS .)
    FOR             reduce using rule 18 (assignment -> variable DMINUS .)
    BREAK           reduce using rule 18 (assignment -> variable DMINUS .)
    DEF             reduce using rule 18 (assignment -> variable DMINUS .)
    CLASS           reduce using rule 18 (assignment -> variable DMINUS .)
    RETURN          reduce using rule 18 (assignment -> variable DMINUS .)
    ID              reduce using rule 18 (assignment -> variable DMINUS .)
    STRING          reduce using rule 18 (assignment -> variable DMINUS .)
    LBRACKET        reduce using rule 18 (assignment -> variable DMINUS .)
    NUMBER          reduce using rule 18 (assignment -> variable DMINUS .)
    LPAREN          reduce using rule 18 (assignment -> variable DMINUS .)
    LEN             reduce using rule 18 (assignment -> variable DMINUS .)
    $end            reduce using rule 18 (assignment -> variable DMINUS .)
    SEMICOLON       reduce using rule 18 (assignment -> variable DMINUS .)
    RBRACE          reduce using rule 18 (assignment -> variable DMINUS .)
    RPAREN          reduce using rule 18 (assignment -> variable DMINUS .)


state 43

    (19) variable -> variable LBRACKET . expr RBRACKET
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    variable                       shift and go to state 49
    expr                           shift and go to state 67
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 44

    (27) term -> term TIMES . factor
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    factor                         shift and go to state 68
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 45

    (28) term -> term DIVIDE . factor
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    factor                         shift and go to state 69
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 46

    (29) term -> term EDIVIDE . factor
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    factor                         shift and go to state 70
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 47

    (39) print -> PRINT LPAREN . exprs RPAREN
    (40) print -> PRINT LPAREN . RPAREN
    (36) exprs -> . exprs COMMA expr
    (37) exprs -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RPAREN          shift and go to state 72
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    exprs                          shift and go to state 71
    expr                           shift and go to state 58
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 48

    (35) factor -> LPAREN expr . RPAREN
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    RPAREN          shift and go to state 73
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 49

    (31) factor -> variable .
    (19) variable -> variable . LBRACKET expr RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 31 (factor -> variable .)
    DIVIDE          reduce using rule 31 (factor -> variable .)
    EDIVIDE         reduce using rule 31 (factor -> variable .)
    RPAREN          reduce using rule 31 (factor -> variable .)
    PLUS            reduce using rule 31 (factor -> variable .)
    MINUS           reduce using rule 31 (factor -> variable .)
    COMMA           reduce using rule 31 (factor -> variable .)
    PRINT           reduce using rule 31 (factor -> variable .)
    IF              reduce using rule 31 (factor -> variable .)
    WHILE           reduce using rule 31 (factor -> variable .)
    FOR             reduce using rule 31 (factor -> variable .)
    BREAK           reduce using rule 31 (factor -> variable .)
    DEF             reduce using rule 31 (factor -> variable .)
    CLASS           reduce using rule 31 (factor -> variable .)
    RETURN          reduce using rule 31 (factor -> variable .)
    ID              reduce using rule 31 (factor -> variable .)
    STRING          reduce using rule 31 (factor -> variable .)
    NUMBER          reduce using rule 31 (factor -> variable .)
    LPAREN          reduce using rule 31 (factor -> variable .)
    LEN             reduce using rule 31 (factor -> variable .)
    $end            reduce using rule 31 (factor -> variable .)
    RBRACE          reduce using rule 31 (factor -> variable .)
    RBRACKET        reduce using rule 31 (factor -> variable .)
    SEMICOLON       reduce using rule 31 (factor -> variable .)
    LT              reduce using rule 31 (factor -> variable .)
    LE              reduce using rule 31 (factor -> variable .)
    GT              reduce using rule 31 (factor -> variable .)
    GE              reduce using rule 31 (factor -> variable .)
    EQ              reduce using rule 31 (factor -> variable .)
    NE              reduce using rule 31 (factor -> variable .)
    AND             reduce using rule 31 (factor -> variable .)
    OR              reduce using rule 31 (factor -> variable .)
    LBRACKET        shift and go to state 43

  ! LBRACKET        [ reduce using rule 31 (factor -> variable .) ]


state 50

    (55) if -> IF LPAREN . condition RPAREN LBRACE statements RBRACE
    (56) if -> IF LPAREN . condition RPAREN LBRACE statements RBRACE else
    (43) condition -> . condition OR join
    (44) condition -> . join
    (45) join -> . join AND equality
    (46) join -> . equality
    (47) equality -> . equality EQ rel
    (48) equality -> . equality NE rel
    (49) equality -> . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    condition                      shift and go to state 74
    join                           shift and go to state 75
    equality                       shift and go to state 76
    rel                            shift and go to state 77
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 51

    (60) while -> WHILE LPAREN . condition RPAREN LBRACE statements RBRACE
    (43) condition -> . condition OR join
    (44) condition -> . join
    (45) join -> . join AND equality
    (46) join -> . equality
    (47) equality -> . equality EQ rel
    (48) equality -> . equality NE rel
    (49) equality -> . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    condition                      shift and go to state 79
    join                           shift and go to state 75
    equality                       shift and go to state 76
    rel                            shift and go to state 77
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 52

    (61) for -> FOR LPAREN . assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID

    ID              shift and go to state 82

    assignment                     shift and go to state 80
    variable                       shift and go to state 81

state 53

    (63) function -> DEF ID . LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> DEF ID . LPAREN RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 83


state 54

    (20) variable -> ID DOT . ID
    (69) call -> ID DOT . ID LPAREN exprs RPAREN
    (70) call -> ID DOT . ID LPAREN RPAREN

    ID              shift and go to state 84


state 55

    (67) call -> ID LPAREN . exprs RPAREN
    (68) call -> ID LPAREN . RPAREN
    (36) exprs -> . exprs COMMA expr
    (37) exprs -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RPAREN          shift and go to state 86
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    exprs                          shift and go to state 85
    expr                           shift and go to state 58
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 56

    (73) class -> CLASS ID . LBRACE functions RBRACE

    LBRACE          shift and go to state 87


state 57

    (72) return -> RETURN exprs .
    (36) exprs -> exprs . COMMA expr

    PRINT           reduce using rule 72 (return -> RETURN exprs .)
    IF              reduce using rule 72 (return -> RETURN exprs .)
    WHILE           reduce using rule 72 (return -> RETURN exprs .)
    FOR             reduce using rule 72 (return -> RETURN exprs .)
    BREAK           reduce using rule 72 (return -> RETURN exprs .)
    DEF             reduce using rule 72 (return -> RETURN exprs .)
    CLASS           reduce using rule 72 (return -> RETURN exprs .)
    RETURN          reduce using rule 72 (return -> RETURN exprs .)
    ID              reduce using rule 72 (return -> RETURN exprs .)
    STRING          reduce using rule 72 (return -> RETURN exprs .)
    LBRACKET        reduce using rule 72 (return -> RETURN exprs .)
    NUMBER          reduce using rule 72 (return -> RETURN exprs .)
    LPAREN          reduce using rule 72 (return -> RETURN exprs .)
    LEN             reduce using rule 72 (return -> RETURN exprs .)
    $end            reduce using rule 72 (return -> RETURN exprs .)
    RBRACE          reduce using rule 72 (return -> RETURN exprs .)
    COMMA           shift and go to state 88


state 58

    (37) exprs -> expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    COMMA           reduce using rule 37 (exprs -> expr .)
    PRINT           reduce using rule 37 (exprs -> expr .)
    IF              reduce using rule 37 (exprs -> expr .)
    WHILE           reduce using rule 37 (exprs -> expr .)
    FOR             reduce using rule 37 (exprs -> expr .)
    BREAK           reduce using rule 37 (exprs -> expr .)
    DEF             reduce using rule 37 (exprs -> expr .)
    CLASS           reduce using rule 37 (exprs -> expr .)
    RETURN          reduce using rule 37 (exprs -> expr .)
    ID              reduce using rule 37 (exprs -> expr .)
    STRING          reduce using rule 37 (exprs -> expr .)
    LBRACKET        reduce using rule 37 (exprs -> expr .)
    NUMBER          reduce using rule 37 (exprs -> expr .)
    LPAREN          reduce using rule 37 (exprs -> expr .)
    LEN             reduce using rule 37 (exprs -> expr .)
    $end            reduce using rule 37 (exprs -> expr .)
    RBRACE          reduce using rule 37 (exprs -> expr .)
    RBRACKET        reduce using rule 37 (exprs -> expr .)
    RPAREN          reduce using rule 37 (exprs -> expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 59

    (41) array -> LBRACKET exprs . RBRACKET
    (36) exprs -> exprs . COMMA expr

    RBRACKET        shift and go to state 89
    COMMA           shift and go to state 88


state 60

    (42) array -> LBRACKET RBRACKET .

    PLUS            reduce using rule 42 (array -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 42 (array -> LBRACKET RBRACKET .)
    PRINT           reduce using rule 42 (array -> LBRACKET RBRACKET .)
    IF              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 42 (array -> LBRACKET RBRACKET .)
    FOR             reduce using rule 42 (array -> LBRACKET RBRACKET .)
    BREAK           reduce using rule 42 (array -> LBRACKET RBRACKET .)
    DEF             reduce using rule 42 (array -> LBRACKET RBRACKET .)
    CLASS           reduce using rule 42 (array -> LBRACKET RBRACKET .)
    RETURN          reduce using rule 42 (array -> LBRACKET RBRACKET .)
    ID              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    STRING          reduce using rule 42 (array -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 42 (array -> LBRACKET RBRACKET .)
    NUMBER          reduce using rule 42 (array -> LBRACKET RBRACKET .)
    LPAREN          reduce using rule 42 (array -> LBRACKET RBRACKET .)
    LEN             reduce using rule 42 (array -> LBRACKET RBRACKET .)
    $end            reduce using rule 42 (array -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 42 (array -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 42 (array -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 42 (array -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 42 (array -> LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 42 (array -> LBRACKET RBRACKET .)
    LT              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    LE              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    GT              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    GE              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    EQ              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    NE              reduce using rule 42 (array -> LBRACKET RBRACKET .)
    AND             reduce using rule 42 (array -> LBRACKET RBRACKET .)
    OR              reduce using rule 42 (array -> LBRACKET RBRACKET .)


state 61

    (38) len -> LEN LPAREN . variable RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID

    ID              shift and go to state 82

    variable                       shift and go to state 90

state 62

    (22) expr -> expr PLUS term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor
    (29) term -> term . EDIVIDE factor

    PLUS            reduce using rule 22 (expr -> expr PLUS term .)
    MINUS           reduce using rule 22 (expr -> expr PLUS term .)
    PRINT           reduce using rule 22 (expr -> expr PLUS term .)
    IF              reduce using rule 22 (expr -> expr PLUS term .)
    WHILE           reduce using rule 22 (expr -> expr PLUS term .)
    FOR             reduce using rule 22 (expr -> expr PLUS term .)
    BREAK           reduce using rule 22 (expr -> expr PLUS term .)
    DEF             reduce using rule 22 (expr -> expr PLUS term .)
    CLASS           reduce using rule 22 (expr -> expr PLUS term .)
    RETURN          reduce using rule 22 (expr -> expr PLUS term .)
    ID              reduce using rule 22 (expr -> expr PLUS term .)
    STRING          reduce using rule 22 (expr -> expr PLUS term .)
    LBRACKET        reduce using rule 22 (expr -> expr PLUS term .)
    NUMBER          reduce using rule 22 (expr -> expr PLUS term .)
    LPAREN          reduce using rule 22 (expr -> expr PLUS term .)
    LEN             reduce using rule 22 (expr -> expr PLUS term .)
    $end            reduce using rule 22 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 22 (expr -> expr PLUS term .)
    COMMA           reduce using rule 22 (expr -> expr PLUS term .)
    RBRACE          reduce using rule 22 (expr -> expr PLUS term .)
    RBRACKET        reduce using rule 22 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 22 (expr -> expr PLUS term .)
    LT              reduce using rule 22 (expr -> expr PLUS term .)
    LE              reduce using rule 22 (expr -> expr PLUS term .)
    GT              reduce using rule 22 (expr -> expr PLUS term .)
    GE              reduce using rule 22 (expr -> expr PLUS term .)
    EQ              reduce using rule 22 (expr -> expr PLUS term .)
    NE              reduce using rule 22 (expr -> expr PLUS term .)
    AND             reduce using rule 22 (expr -> expr PLUS term .)
    OR              reduce using rule 22 (expr -> expr PLUS term .)
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    EDIVIDE         shift and go to state 46


state 63

    (23) expr -> expr MINUS term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor
    (29) term -> term . EDIVIDE factor

    PLUS            reduce using rule 23 (expr -> expr MINUS term .)
    MINUS           reduce using rule 23 (expr -> expr MINUS term .)
    PRINT           reduce using rule 23 (expr -> expr MINUS term .)
    IF              reduce using rule 23 (expr -> expr MINUS term .)
    WHILE           reduce using rule 23 (expr -> expr MINUS term .)
    FOR             reduce using rule 23 (expr -> expr MINUS term .)
    BREAK           reduce using rule 23 (expr -> expr MINUS term .)
    DEF             reduce using rule 23 (expr -> expr MINUS term .)
    CLASS           reduce using rule 23 (expr -> expr MINUS term .)
    RETURN          reduce using rule 23 (expr -> expr MINUS term .)
    ID              reduce using rule 23 (expr -> expr MINUS term .)
    STRING          reduce using rule 23 (expr -> expr MINUS term .)
    LBRACKET        reduce using rule 23 (expr -> expr MINUS term .)
    NUMBER          reduce using rule 23 (expr -> expr MINUS term .)
    LPAREN          reduce using rule 23 (expr -> expr MINUS term .)
    LEN             reduce using rule 23 (expr -> expr MINUS term .)
    $end            reduce using rule 23 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 23 (expr -> expr MINUS term .)
    COMMA           reduce using rule 23 (expr -> expr MINUS term .)
    RBRACE          reduce using rule 23 (expr -> expr MINUS term .)
    RBRACKET        reduce using rule 23 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 23 (expr -> expr MINUS term .)
    LT              reduce using rule 23 (expr -> expr MINUS term .)
    LE              reduce using rule 23 (expr -> expr MINUS term .)
    GT              reduce using rule 23 (expr -> expr MINUS term .)
    GE              reduce using rule 23 (expr -> expr MINUS term .)
    EQ              reduce using rule 23 (expr -> expr MINUS term .)
    NE              reduce using rule 23 (expr -> expr MINUS term .)
    AND             reduce using rule 23 (expr -> expr MINUS term .)
    OR              reduce using rule 23 (expr -> expr MINUS term .)
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    EDIVIDE         shift and go to state 46


state 64

    (14) assignment -> variable ASSIGN expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    PRINT           reduce using rule 14 (assignment -> variable ASSIGN expr .)
    IF              reduce using rule 14 (assignment -> variable ASSIGN expr .)
    WHILE           reduce using rule 14 (assignment -> variable ASSIGN expr .)
    FOR             reduce using rule 14 (assignment -> variable ASSIGN expr .)
    BREAK           reduce using rule 14 (assignment -> variable ASSIGN expr .)
    DEF             reduce using rule 14 (assignment -> variable ASSIGN expr .)
    CLASS           reduce using rule 14 (assignment -> variable ASSIGN expr .)
    RETURN          reduce using rule 14 (assignment -> variable ASSIGN expr .)
    ID              reduce using rule 14 (assignment -> variable ASSIGN expr .)
    STRING          reduce using rule 14 (assignment -> variable ASSIGN expr .)
    LBRACKET        reduce using rule 14 (assignment -> variable ASSIGN expr .)
    NUMBER          reduce using rule 14 (assignment -> variable ASSIGN expr .)
    LPAREN          reduce using rule 14 (assignment -> variable ASSIGN expr .)
    LEN             reduce using rule 14 (assignment -> variable ASSIGN expr .)
    $end            reduce using rule 14 (assignment -> variable ASSIGN expr .)
    SEMICOLON       reduce using rule 14 (assignment -> variable ASSIGN expr .)
    RBRACE          reduce using rule 14 (assignment -> variable ASSIGN expr .)
    RPAREN          reduce using rule 14 (assignment -> variable ASSIGN expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 65

    (15) assignment -> variable MINEQUAL expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    PRINT           reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    IF              reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    WHILE           reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    FOR             reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    BREAK           reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    DEF             reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    CLASS           reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    RETURN          reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    ID              reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    STRING          reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    LBRACKET        reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    NUMBER          reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    LPAREN          reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    LEN             reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    $end            reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    SEMICOLON       reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    RBRACE          reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    RPAREN          reduce using rule 15 (assignment -> variable MINEQUAL expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 66

    (16) assignment -> variable PLUSEQUAL expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    PRINT           reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    IF              reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    WHILE           reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    FOR             reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    BREAK           reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    DEF             reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    CLASS           reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    RETURN          reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    ID              reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    STRING          reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    LBRACKET        reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    NUMBER          reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    LPAREN          reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    LEN             reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    $end            reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    SEMICOLON       reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    RBRACE          reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    RPAREN          reduce using rule 16 (assignment -> variable PLUSEQUAL expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 67

    (19) variable -> variable LBRACKET expr . RBRACKET
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    RBRACKET        shift and go to state 91
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 68

    (27) term -> term TIMES factor .

    TIMES           reduce using rule 27 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 27 (term -> term TIMES factor .)
    EDIVIDE         reduce using rule 27 (term -> term TIMES factor .)
    PLUS            reduce using rule 27 (term -> term TIMES factor .)
    MINUS           reduce using rule 27 (term -> term TIMES factor .)
    PRINT           reduce using rule 27 (term -> term TIMES factor .)
    IF              reduce using rule 27 (term -> term TIMES factor .)
    WHILE           reduce using rule 27 (term -> term TIMES factor .)
    FOR             reduce using rule 27 (term -> term TIMES factor .)
    BREAK           reduce using rule 27 (term -> term TIMES factor .)
    DEF             reduce using rule 27 (term -> term TIMES factor .)
    CLASS           reduce using rule 27 (term -> term TIMES factor .)
    RETURN          reduce using rule 27 (term -> term TIMES factor .)
    ID              reduce using rule 27 (term -> term TIMES factor .)
    STRING          reduce using rule 27 (term -> term TIMES factor .)
    LBRACKET        reduce using rule 27 (term -> term TIMES factor .)
    NUMBER          reduce using rule 27 (term -> term TIMES factor .)
    LPAREN          reduce using rule 27 (term -> term TIMES factor .)
    LEN             reduce using rule 27 (term -> term TIMES factor .)
    $end            reduce using rule 27 (term -> term TIMES factor .)
    RPAREN          reduce using rule 27 (term -> term TIMES factor .)
    COMMA           reduce using rule 27 (term -> term TIMES factor .)
    RBRACE          reduce using rule 27 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 27 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 27 (term -> term TIMES factor .)
    LT              reduce using rule 27 (term -> term TIMES factor .)
    LE              reduce using rule 27 (term -> term TIMES factor .)
    GT              reduce using rule 27 (term -> term TIMES factor .)
    GE              reduce using rule 27 (term -> term TIMES factor .)
    EQ              reduce using rule 27 (term -> term TIMES factor .)
    NE              reduce using rule 27 (term -> term TIMES factor .)
    AND             reduce using rule 27 (term -> term TIMES factor .)
    OR              reduce using rule 27 (term -> term TIMES factor .)


state 69

    (28) term -> term DIVIDE factor .

    TIMES           reduce using rule 28 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 28 (term -> term DIVIDE factor .)
    EDIVIDE         reduce using rule 28 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 28 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 28 (term -> term DIVIDE factor .)
    PRINT           reduce using rule 28 (term -> term DIVIDE factor .)
    IF              reduce using rule 28 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 28 (term -> term DIVIDE factor .)
    FOR             reduce using rule 28 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 28 (term -> term DIVIDE factor .)
    DEF             reduce using rule 28 (term -> term DIVIDE factor .)
    CLASS           reduce using rule 28 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 28 (term -> term DIVIDE factor .)
    ID              reduce using rule 28 (term -> term DIVIDE factor .)
    STRING          reduce using rule 28 (term -> term DIVIDE factor .)
    LBRACKET        reduce using rule 28 (term -> term DIVIDE factor .)
    NUMBER          reduce using rule 28 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 28 (term -> term DIVIDE factor .)
    LEN             reduce using rule 28 (term -> term DIVIDE factor .)
    $end            reduce using rule 28 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 28 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 28 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 28 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 28 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 28 (term -> term DIVIDE factor .)
    LT              reduce using rule 28 (term -> term DIVIDE factor .)
    LE              reduce using rule 28 (term -> term DIVIDE factor .)
    GT              reduce using rule 28 (term -> term DIVIDE factor .)
    GE              reduce using rule 28 (term -> term DIVIDE factor .)
    EQ              reduce using rule 28 (term -> term DIVIDE factor .)
    NE              reduce using rule 28 (term -> term DIVIDE factor .)
    AND             reduce using rule 28 (term -> term DIVIDE factor .)
    OR              reduce using rule 28 (term -> term DIVIDE factor .)


state 70

    (29) term -> term EDIVIDE factor .

    TIMES           reduce using rule 29 (term -> term EDIVIDE factor .)
    DIVIDE          reduce using rule 29 (term -> term EDIVIDE factor .)
    EDIVIDE         reduce using rule 29 (term -> term EDIVIDE factor .)
    PLUS            reduce using rule 29 (term -> term EDIVIDE factor .)
    MINUS           reduce using rule 29 (term -> term EDIVIDE factor .)
    PRINT           reduce using rule 29 (term -> term EDIVIDE factor .)
    IF              reduce using rule 29 (term -> term EDIVIDE factor .)
    WHILE           reduce using rule 29 (term -> term EDIVIDE factor .)
    FOR             reduce using rule 29 (term -> term EDIVIDE factor .)
    BREAK           reduce using rule 29 (term -> term EDIVIDE factor .)
    DEF             reduce using rule 29 (term -> term EDIVIDE factor .)
    CLASS           reduce using rule 29 (term -> term EDIVIDE factor .)
    RETURN          reduce using rule 29 (term -> term EDIVIDE factor .)
    ID              reduce using rule 29 (term -> term EDIVIDE factor .)
    STRING          reduce using rule 29 (term -> term EDIVIDE factor .)
    LBRACKET        reduce using rule 29 (term -> term EDIVIDE factor .)
    NUMBER          reduce using rule 29 (term -> term EDIVIDE factor .)
    LPAREN          reduce using rule 29 (term -> term EDIVIDE factor .)
    LEN             reduce using rule 29 (term -> term EDIVIDE factor .)
    $end            reduce using rule 29 (term -> term EDIVIDE factor .)
    RPAREN          reduce using rule 29 (term -> term EDIVIDE factor .)
    COMMA           reduce using rule 29 (term -> term EDIVIDE factor .)
    RBRACE          reduce using rule 29 (term -> term EDIVIDE factor .)
    RBRACKET        reduce using rule 29 (term -> term EDIVIDE factor .)
    SEMICOLON       reduce using rule 29 (term -> term EDIVIDE factor .)
    LT              reduce using rule 29 (term -> term EDIVIDE factor .)
    LE              reduce using rule 29 (term -> term EDIVIDE factor .)
    GT              reduce using rule 29 (term -> term EDIVIDE factor .)
    GE              reduce using rule 29 (term -> term EDIVIDE factor .)
    EQ              reduce using rule 29 (term -> term EDIVIDE factor .)
    NE              reduce using rule 29 (term -> term EDIVIDE factor .)
    AND             reduce using rule 29 (term -> term EDIVIDE factor .)
    OR              reduce using rule 29 (term -> term EDIVIDE factor .)


state 71

    (39) print -> PRINT LPAREN exprs . RPAREN
    (36) exprs -> exprs . COMMA expr

    RPAREN          shift and go to state 92
    COMMA           shift and go to state 88


state 72

    (40) print -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    WHILE           reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    BREAK           reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    DEF             reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    CLASS           reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    ID              reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    STRING          reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    LBRACKET        reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    NUMBER          reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    LPAREN          reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    LEN             reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 40 (print -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 40 (print -> PRINT LPAREN RPAREN .)


state 73

    (35) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    EDIVIDE         reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    PRINT           reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    IF              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    FOR             reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    BREAK           reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    DEF             reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    CLASS           reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    ID              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    STRING          reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    NUMBER          reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    LEN             reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    $end            reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 35 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 35 (factor -> LPAREN expr RPAREN .)


state 74

    (55) if -> IF LPAREN condition . RPAREN LBRACE statements RBRACE
    (56) if -> IF LPAREN condition . RPAREN LBRACE statements RBRACE else
    (43) condition -> condition . OR join

    RPAREN          shift and go to state 93
    OR              shift and go to state 94


state 75

    (44) condition -> join .
    (45) join -> join . AND equality

    RPAREN          reduce using rule 44 (condition -> join .)
    OR              reduce using rule 44 (condition -> join .)
    SEMICOLON       reduce using rule 44 (condition -> join .)
    AND             shift and go to state 95


state 76

    (46) join -> equality .
    (47) equality -> equality . EQ rel
    (48) equality -> equality . NE rel

    AND             reduce using rule 46 (join -> equality .)
    RPAREN          reduce using rule 46 (join -> equality .)
    OR              reduce using rule 46 (join -> equality .)
    SEMICOLON       reduce using rule 46 (join -> equality .)
    EQ              shift and go to state 96
    NE              shift and go to state 97


state 77

    (49) equality -> rel .

    EQ              reduce using rule 49 (equality -> rel .)
    NE              reduce using rule 49 (equality -> rel .)
    AND             reduce using rule 49 (equality -> rel .)
    RPAREN          reduce using rule 49 (equality -> rel .)
    OR              reduce using rule 49 (equality -> rel .)
    SEMICOLON       reduce using rule 49 (equality -> rel .)


state 78

    (50) rel -> expr . LT expr
    (51) rel -> expr . LE expr
    (52) rel -> expr . GT expr
    (53) rel -> expr . GE expr
    (54) rel -> expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    LT              shift and go to state 98
    LE              shift and go to state 99
    GT              shift and go to state 100
    GE              shift and go to state 101
    EQ              reduce using rule 54 (rel -> expr .)
    NE              reduce using rule 54 (rel -> expr .)
    AND             reduce using rule 54 (rel -> expr .)
    RPAREN          reduce using rule 54 (rel -> expr .)
    OR              reduce using rule 54 (rel -> expr .)
    SEMICOLON       reduce using rule 54 (rel -> expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 79

    (60) while -> WHILE LPAREN condition . RPAREN LBRACE statements RBRACE
    (43) condition -> condition . OR join

    RPAREN          shift and go to state 102
    OR              shift and go to state 94


state 80

    (61) for -> FOR LPAREN assignment . SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 103


state 81

    (14) assignment -> variable . ASSIGN expr
    (15) assignment -> variable . MINEQUAL expr
    (16) assignment -> variable . PLUSEQUAL expr
    (17) assignment -> variable . DPLUS
    (18) assignment -> variable . DMINUS
    (19) variable -> variable . LBRACKET expr RBRACKET

    ASSIGN          shift and go to state 38
    MINEQUAL        shift and go to state 39
    PLUSEQUAL       shift and go to state 40
    DPLUS           shift and go to state 41
    DMINUS          shift and go to state 42
    LBRACKET        shift and go to state 43


state 82

    (20) variable -> ID . DOT ID
    (21) variable -> ID .

    DOT             shift and go to state 104
    ASSIGN          reduce using rule 21 (variable -> ID .)
    MINEQUAL        reduce using rule 21 (variable -> ID .)
    PLUSEQUAL       reduce using rule 21 (variable -> ID .)
    DPLUS           reduce using rule 21 (variable -> ID .)
    DMINUS          reduce using rule 21 (variable -> ID .)
    LBRACKET        reduce using rule 21 (variable -> ID .)
    RPAREN          reduce using rule 21 (variable -> ID .)


state 83

    (63) function -> DEF ID LPAREN . args RPAREN LBRACE statements RBRACE
    (64) function -> DEF ID LPAREN . RPAREN LBRACE statements RBRACE
    (65) args -> . args COMMA ID
    (66) args -> . ID

    RPAREN          shift and go to state 107
    ID              shift and go to state 105

    args                           shift and go to state 106

state 84

    (20) variable -> ID DOT ID .
    (69) call -> ID DOT ID . LPAREN exprs RPAREN
    (70) call -> ID DOT ID . LPAREN RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    ASSIGN          reduce using rule 20 (variable -> ID DOT ID .)
    MINEQUAL        reduce using rule 20 (variable -> ID DOT ID .)
    PLUSEQUAL       reduce using rule 20 (variable -> ID DOT ID .)
    DPLUS           reduce using rule 20 (variable -> ID DOT ID .)
    DMINUS          reduce using rule 20 (variable -> ID DOT ID .)
    LBRACKET        reduce using rule 20 (variable -> ID DOT ID .)
    TIMES           reduce using rule 20 (variable -> ID DOT ID .)
    DIVIDE          reduce using rule 20 (variable -> ID DOT ID .)
    EDIVIDE         reduce using rule 20 (variable -> ID DOT ID .)
    PLUS            reduce using rule 20 (variable -> ID DOT ID .)
    MINUS           reduce using rule 20 (variable -> ID DOT ID .)
    PRINT           reduce using rule 20 (variable -> ID DOT ID .)
    IF              reduce using rule 20 (variable -> ID DOT ID .)
    WHILE           reduce using rule 20 (variable -> ID DOT ID .)
    FOR             reduce using rule 20 (variable -> ID DOT ID .)
    BREAK           reduce using rule 20 (variable -> ID DOT ID .)
    DEF             reduce using rule 20 (variable -> ID DOT ID .)
    CLASS           reduce using rule 20 (variable -> ID DOT ID .)
    RETURN          reduce using rule 20 (variable -> ID DOT ID .)
    ID              reduce using rule 20 (variable -> ID DOT ID .)
    STRING          reduce using rule 20 (variable -> ID DOT ID .)
    NUMBER          reduce using rule 20 (variable -> ID DOT ID .)
    LEN             reduce using rule 20 (variable -> ID DOT ID .)
    $end            reduce using rule 20 (variable -> ID DOT ID .)
    RPAREN          reduce using rule 20 (variable -> ID DOT ID .)
    COMMA           reduce using rule 20 (variable -> ID DOT ID .)
    RBRACE          reduce using rule 20 (variable -> ID DOT ID .)
    RBRACKET        reduce using rule 20 (variable -> ID DOT ID .)
    SEMICOLON       reduce using rule 20 (variable -> ID DOT ID .)
    LT              reduce using rule 20 (variable -> ID DOT ID .)
    LE              reduce using rule 20 (variable -> ID DOT ID .)
    GT              reduce using rule 20 (variable -> ID DOT ID .)
    GE              reduce using rule 20 (variable -> ID DOT ID .)
    EQ              reduce using rule 20 (variable -> ID DOT ID .)
    NE              reduce using rule 20 (variable -> ID DOT ID .)
    AND             reduce using rule 20 (variable -> ID DOT ID .)
    OR              reduce using rule 20 (variable -> ID DOT ID .)
    LPAREN          shift and go to state 108

  ! LPAREN          [ reduce using rule 20 (variable -> ID DOT ID .) ]


state 85

    (67) call -> ID LPAREN exprs . RPAREN
    (36) exprs -> exprs . COMMA expr

    RPAREN          shift and go to state 109
    COMMA           shift and go to state 88


state 86

    (68) call -> ID LPAREN RPAREN .

    TIMES           reduce using rule 68 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 68 (call -> ID LPAREN RPAREN .)
    EDIVIDE         reduce using rule 68 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 68 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 68 (call -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 68 (call -> ID LPAREN RPAREN .)
    IF              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 68 (call -> ID LPAREN RPAREN .)
    FOR             reduce using rule 68 (call -> ID LPAREN RPAREN .)
    BREAK           reduce using rule 68 (call -> ID LPAREN RPAREN .)
    DEF             reduce using rule 68 (call -> ID LPAREN RPAREN .)
    CLASS           reduce using rule 68 (call -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 68 (call -> ID LPAREN RPAREN .)
    ID              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    STRING          reduce using rule 68 (call -> ID LPAREN RPAREN .)
    LBRACKET        reduce using rule 68 (call -> ID LPAREN RPAREN .)
    NUMBER          reduce using rule 68 (call -> ID LPAREN RPAREN .)
    LPAREN          reduce using rule 68 (call -> ID LPAREN RPAREN .)
    LEN             reduce using rule 68 (call -> ID LPAREN RPAREN .)
    $end            reduce using rule 68 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 68 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 68 (call -> ID LPAREN RPAREN .)
    RBRACE          reduce using rule 68 (call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 68 (call -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 68 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    LE              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    GE              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    NE              reduce using rule 68 (call -> ID LPAREN RPAREN .)
    AND             reduce using rule 68 (call -> ID LPAREN RPAREN .)
    OR              reduce using rule 68 (call -> ID LPAREN RPAREN .)


state 87

    (73) class -> CLASS ID LBRACE . functions RBRACE
    (74) functions -> . functions function
    (75) functions -> . function
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE

    DEF             shift and go to state 24

    functions                      shift and go to state 110
    function                       shift and go to state 111

state 88

    (36) exprs -> exprs COMMA . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    expr                           shift and go to state 112
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 89

    (41) array -> LBRACKET exprs RBRACKET .

    PLUS            reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    MINUS           reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    PRINT           reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    IF              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    WHILE           reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    FOR             reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    BREAK           reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    DEF             reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    CLASS           reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    RETURN          reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    ID              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    STRING          reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    LBRACKET        reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    NUMBER          reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    LPAREN          reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    LEN             reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    $end            reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    RPAREN          reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    COMMA           reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    RBRACE          reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    RBRACKET        reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    SEMICOLON       reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    LT              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    LE              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    GT              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    GE              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    EQ              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    NE              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    AND             reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)
    OR              reduce using rule 41 (array -> LBRACKET exprs RBRACKET .)


state 90

    (38) len -> LEN LPAREN variable . RPAREN
    (19) variable -> variable . LBRACKET expr RBRACKET

    RPAREN          shift and go to state 113
    LBRACKET        shift and go to state 43


state 91

    (19) variable -> variable LBRACKET expr RBRACKET .

    ASSIGN          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    MINEQUAL        reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    PLUSEQUAL       reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    DPLUS           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    DMINUS          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    EDIVIDE         reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    PRINT           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    IF              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    WHILE           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    FOR             reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    BREAK           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    DEF             reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    CLASS           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    RETURN          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    ID              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    STRING          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    NUMBER          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    LEN             reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    $end            reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    LT              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    LE              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    GT              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    GE              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    EQ              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    NE              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    AND             reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)
    OR              reduce using rule 19 (variable -> variable LBRACKET expr RBRACKET .)


state 92

    (39) print -> PRINT LPAREN exprs RPAREN .

    PRINT           reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    IF              reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    WHILE           reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    FOR             reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    BREAK           reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    DEF             reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    CLASS           reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    RETURN          reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    ID              reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    STRING          reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    LBRACKET        reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    NUMBER          reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    LPAREN          reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    LEN             reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    $end            reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)
    RBRACE          reduce using rule 39 (print -> PRINT LPAREN exprs RPAREN .)


state 93

    (55) if -> IF LPAREN condition RPAREN . LBRACE statements RBRACE
    (56) if -> IF LPAREN condition RPAREN . LBRACE statements RBRACE else

    LBRACE          shift and go to state 114


state 94

    (43) condition -> condition OR . join
    (45) join -> . join AND equality
    (46) join -> . equality
    (47) equality -> . equality EQ rel
    (48) equality -> . equality NE rel
    (49) equality -> . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    join                           shift and go to state 115
    equality                       shift and go to state 76
    rel                            shift and go to state 77
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 95

    (45) join -> join AND . equality
    (47) equality -> . equality EQ rel
    (48) equality -> . equality NE rel
    (49) equality -> . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    equality                       shift and go to state 116
    rel                            shift and go to state 77
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 96

    (47) equality -> equality EQ . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    rel                            shift and go to state 117
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 97

    (48) equality -> equality NE . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    rel                            shift and go to state 118
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 98

    (50) rel -> expr LT . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    expr                           shift and go to state 119
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 99

    (51) rel -> expr LE . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    expr                           shift and go to state 120
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 100

    (52) rel -> expr GT . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    expr                           shift and go to state 121
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 101

    (53) rel -> expr GE . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    expr                           shift and go to state 122
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 102

    (60) while -> WHILE LPAREN condition RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 123


state 103

    (61) for -> FOR LPAREN assignment SEMICOLON . condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (43) condition -> . condition OR join
    (44) condition -> . join
    (45) join -> . join AND equality
    (46) join -> . equality
    (47) equality -> . equality EQ rel
    (48) equality -> . equality NE rel
    (49) equality -> . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    condition                      shift and go to state 124
    join                           shift and go to state 75
    equality                       shift and go to state 76
    rel                            shift and go to state 77
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 104

    (20) variable -> ID DOT . ID

    ID              shift and go to state 125


state 105

    (66) args -> ID .

    RPAREN          reduce using rule 66 (args -> ID .)
    COMMA           reduce using rule 66 (args -> ID .)


state 106

    (63) function -> DEF ID LPAREN args . RPAREN LBRACE statements RBRACE
    (65) args -> args . COMMA ID

    RPAREN          shift and go to state 126
    COMMA           shift and go to state 127


state 107

    (64) function -> DEF ID LPAREN RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 128


state 108

    (69) call -> ID DOT ID LPAREN . exprs RPAREN
    (70) call -> ID DOT ID LPAREN . RPAREN
    (36) exprs -> . exprs COMMA expr
    (37) exprs -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RPAREN          shift and go to state 130
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    exprs                          shift and go to state 129
    expr                           shift and go to state 58
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 109

    (67) call -> ID LPAREN exprs RPAREN .

    TIMES           reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    DIVIDE          reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    EDIVIDE         reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    PLUS            reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    MINUS           reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    PRINT           reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    IF              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    WHILE           reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    FOR             reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    BREAK           reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    DEF             reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    CLASS           reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    RETURN          reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    ID              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    STRING          reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    LBRACKET        reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    NUMBER          reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    LPAREN          reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    LEN             reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    $end            reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    RPAREN          reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    COMMA           reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    RBRACE          reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    RBRACKET        reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    SEMICOLON       reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    LT              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    LE              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    GT              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    GE              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    EQ              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    NE              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    AND             reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)
    OR              reduce using rule 67 (call -> ID LPAREN exprs RPAREN .)


state 110

    (73) class -> CLASS ID LBRACE functions . RBRACE
    (74) functions -> functions . function
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE

    RBRACE          shift and go to state 131
    DEF             shift and go to state 24

    function                       shift and go to state 132

state 111

    (75) functions -> function .

    RBRACE          reduce using rule 75 (functions -> function .)
    DEF             reduce using rule 75 (functions -> function .)


state 112

    (36) exprs -> exprs COMMA expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    COMMA           reduce using rule 36 (exprs -> exprs COMMA expr .)
    PRINT           reduce using rule 36 (exprs -> exprs COMMA expr .)
    IF              reduce using rule 36 (exprs -> exprs COMMA expr .)
    WHILE           reduce using rule 36 (exprs -> exprs COMMA expr .)
    FOR             reduce using rule 36 (exprs -> exprs COMMA expr .)
    BREAK           reduce using rule 36 (exprs -> exprs COMMA expr .)
    DEF             reduce using rule 36 (exprs -> exprs COMMA expr .)
    CLASS           reduce using rule 36 (exprs -> exprs COMMA expr .)
    RETURN          reduce using rule 36 (exprs -> exprs COMMA expr .)
    ID              reduce using rule 36 (exprs -> exprs COMMA expr .)
    STRING          reduce using rule 36 (exprs -> exprs COMMA expr .)
    LBRACKET        reduce using rule 36 (exprs -> exprs COMMA expr .)
    NUMBER          reduce using rule 36 (exprs -> exprs COMMA expr .)
    LPAREN          reduce using rule 36 (exprs -> exprs COMMA expr .)
    LEN             reduce using rule 36 (exprs -> exprs COMMA expr .)
    $end            reduce using rule 36 (exprs -> exprs COMMA expr .)
    RBRACE          reduce using rule 36 (exprs -> exprs COMMA expr .)
    RBRACKET        reduce using rule 36 (exprs -> exprs COMMA expr .)
    RPAREN          reduce using rule 36 (exprs -> exprs COMMA expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 113

    (38) len -> LEN LPAREN variable RPAREN .

    TIMES           reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    DIVIDE          reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    EDIVIDE         reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    PLUS            reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    MINUS           reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    PRINT           reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    IF              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    WHILE           reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    FOR             reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    BREAK           reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    DEF             reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    CLASS           reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    RETURN          reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    ID              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    STRING          reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    LBRACKET        reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    NUMBER          reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    LPAREN          reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    LEN             reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    $end            reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    RPAREN          reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    COMMA           reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    RBRACE          reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    RBRACKET        reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    SEMICOLON       reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    LT              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    LE              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    GT              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    GE              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    EQ              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    NE              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    AND             reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)
    OR              reduce using rule 38 (len -> LEN LPAREN variable RPAREN .)


state 114

    (55) if -> IF LPAREN condition RPAREN LBRACE . statements RBRACE
    (56) if -> IF LPAREN condition RPAREN LBRACE . statements RBRACE else
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statements                     shift and go to state 133
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 115

    (43) condition -> condition OR join .
    (45) join -> join . AND equality

    RPAREN          reduce using rule 43 (condition -> condition OR join .)
    OR              reduce using rule 43 (condition -> condition OR join .)
    SEMICOLON       reduce using rule 43 (condition -> condition OR join .)
    AND             shift and go to state 95


state 116

    (45) join -> join AND equality .
    (47) equality -> equality . EQ rel
    (48) equality -> equality . NE rel

    AND             reduce using rule 45 (join -> join AND equality .)
    RPAREN          reduce using rule 45 (join -> join AND equality .)
    OR              reduce using rule 45 (join -> join AND equality .)
    SEMICOLON       reduce using rule 45 (join -> join AND equality .)
    EQ              shift and go to state 96
    NE              shift and go to state 97


state 117

    (47) equality -> equality EQ rel .

    EQ              reduce using rule 47 (equality -> equality EQ rel .)
    NE              reduce using rule 47 (equality -> equality EQ rel .)
    AND             reduce using rule 47 (equality -> equality EQ rel .)
    RPAREN          reduce using rule 47 (equality -> equality EQ rel .)
    OR              reduce using rule 47 (equality -> equality EQ rel .)
    SEMICOLON       reduce using rule 47 (equality -> equality EQ rel .)


state 118

    (48) equality -> equality NE rel .

    EQ              reduce using rule 48 (equality -> equality NE rel .)
    NE              reduce using rule 48 (equality -> equality NE rel .)
    AND             reduce using rule 48 (equality -> equality NE rel .)
    RPAREN          reduce using rule 48 (equality -> equality NE rel .)
    OR              reduce using rule 48 (equality -> equality NE rel .)
    SEMICOLON       reduce using rule 48 (equality -> equality NE rel .)


state 119

    (50) rel -> expr LT expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    EQ              reduce using rule 50 (rel -> expr LT expr .)
    NE              reduce using rule 50 (rel -> expr LT expr .)
    AND             reduce using rule 50 (rel -> expr LT expr .)
    RPAREN          reduce using rule 50 (rel -> expr LT expr .)
    OR              reduce using rule 50 (rel -> expr LT expr .)
    SEMICOLON       reduce using rule 50 (rel -> expr LT expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 120

    (51) rel -> expr LE expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    EQ              reduce using rule 51 (rel -> expr LE expr .)
    NE              reduce using rule 51 (rel -> expr LE expr .)
    AND             reduce using rule 51 (rel -> expr LE expr .)
    RPAREN          reduce using rule 51 (rel -> expr LE expr .)
    OR              reduce using rule 51 (rel -> expr LE expr .)
    SEMICOLON       reduce using rule 51 (rel -> expr LE expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 121

    (52) rel -> expr GT expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    EQ              reduce using rule 52 (rel -> expr GT expr .)
    NE              reduce using rule 52 (rel -> expr GT expr .)
    AND             reduce using rule 52 (rel -> expr GT expr .)
    RPAREN          reduce using rule 52 (rel -> expr GT expr .)
    OR              reduce using rule 52 (rel -> expr GT expr .)
    SEMICOLON       reduce using rule 52 (rel -> expr GT expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 122

    (53) rel -> expr GE expr .
    (22) expr -> expr . PLUS term
    (23) expr -> expr . MINUS term

    EQ              reduce using rule 53 (rel -> expr GE expr .)
    NE              reduce using rule 53 (rel -> expr GE expr .)
    AND             reduce using rule 53 (rel -> expr GE expr .)
    RPAREN          reduce using rule 53 (rel -> expr GE expr .)
    OR              reduce using rule 53 (rel -> expr GE expr .)
    SEMICOLON       reduce using rule 53 (rel -> expr GE expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37


state 123

    (60) while -> WHILE LPAREN condition RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statements                     shift and go to state 134
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 124

    (61) for -> FOR LPAREN assignment SEMICOLON condition . SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (43) condition -> condition . OR join

    SEMICOLON       shift and go to state 135
    OR              shift and go to state 94


state 125

    (20) variable -> ID DOT ID .

    ASSIGN          reduce using rule 20 (variable -> ID DOT ID .)
    MINEQUAL        reduce using rule 20 (variable -> ID DOT ID .)
    PLUSEQUAL       reduce using rule 20 (variable -> ID DOT ID .)
    DPLUS           reduce using rule 20 (variable -> ID DOT ID .)
    DMINUS          reduce using rule 20 (variable -> ID DOT ID .)
    LBRACKET        reduce using rule 20 (variable -> ID DOT ID .)
    RPAREN          reduce using rule 20 (variable -> ID DOT ID .)


state 126

    (63) function -> DEF ID LPAREN args RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 136


state 127

    (65) args -> args COMMA . ID

    ID              shift and go to state 137


state 128

    (64) function -> DEF ID LPAREN RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statements                     shift and go to state 138
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 129

    (69) call -> ID DOT ID LPAREN exprs . RPAREN
    (36) exprs -> exprs . COMMA expr

    RPAREN          shift and go to state 139
    COMMA           shift and go to state 88


state 130

    (70) call -> ID DOT ID LPAREN RPAREN .

    TIMES           reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    EDIVIDE         reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    PLUS            reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    MINUS           reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    PRINT           reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    IF              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    WHILE           reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    FOR             reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    BREAK           reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    DEF             reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    CLASS           reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    RETURN          reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    ID              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    STRING          reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    LBRACKET        reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    NUMBER          reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    LPAREN          reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    LEN             reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    $end            reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    RPAREN          reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    COMMA           reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    RBRACE          reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    LT              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    LE              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    GT              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    GE              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    EQ              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    NE              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    AND             reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)
    OR              reduce using rule 70 (call -> ID DOT ID LPAREN RPAREN .)


state 131

    (73) class -> CLASS ID LBRACE functions RBRACE .

    PRINT           reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    IF              reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    WHILE           reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    FOR             reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    BREAK           reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    DEF             reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    CLASS           reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    RETURN          reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    ID              reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    STRING          reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    LBRACKET        reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    NUMBER          reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    LPAREN          reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    LEN             reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    $end            reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)
    RBRACE          reduce using rule 73 (class -> CLASS ID LBRACE functions RBRACE .)


state 132

    (74) functions -> functions function .

    RBRACE          reduce using rule 74 (functions -> functions function .)
    DEF             reduce using rule 74 (functions -> functions function .)


state 133

    (55) if -> IF LPAREN condition RPAREN LBRACE statements . RBRACE
    (56) if -> IF LPAREN condition RPAREN LBRACE statements . RBRACE else
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACE          shift and go to state 140
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statement                      shift and go to state 35
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 134

    (60) while -> WHILE LPAREN condition RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACE          shift and go to state 141
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statement                      shift and go to state 35
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 135

    (61) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON . assignment RPAREN LBRACE statements RBRACE
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID

    ID              shift and go to state 82

    assignment                     shift and go to state 142
    variable                       shift and go to state 81

state 136

    (63) function -> DEF ID LPAREN args RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statements                     shift and go to state 143
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 137

    (65) args -> args COMMA ID .

    RPAREN          reduce using rule 65 (args -> args COMMA ID .)
    COMMA           reduce using rule 65 (args -> args COMMA ID .)


state 138

    (64) function -> DEF ID LPAREN RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACE          shift and go to state 144
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statement                      shift and go to state 35
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 139

    (69) call -> ID DOT ID LPAREN exprs RPAREN .

    TIMES           reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    DIVIDE          reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    EDIVIDE         reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    PLUS            reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    MINUS           reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    PRINT           reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    IF              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    WHILE           reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    FOR             reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    BREAK           reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    DEF             reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    CLASS           reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    RETURN          reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    ID              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    STRING          reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    LBRACKET        reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    NUMBER          reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    LPAREN          reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    LEN             reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    $end            reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    RPAREN          reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    COMMA           reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    RBRACE          reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    RBRACKET        reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    SEMICOLON       reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    LT              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    LE              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    GT              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    GE              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    EQ              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    NE              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    AND             reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)
    OR              reduce using rule 69 (call -> ID DOT ID LPAREN exprs RPAREN .)


state 140

    (55) if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .
    (56) if -> IF LPAREN condition RPAREN LBRACE statements RBRACE . else
    (57) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE
    (58) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE else
    (59) else -> . ELSE LBRACE statements RBRACE

    PRINT           reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    CLASS           reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    STRING          reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 55 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ELIF            shift and go to state 146
    ELSE            shift and go to state 147

    else                           shift and go to state 145

state 141

    (60) while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    CLASS           reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    STRING          reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 60 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)


state 142

    (61) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 148


state 143

    (63) function -> DEF ID LPAREN args RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACE          shift and go to state 149
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statement                      shift and go to state 35
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 144

    (64) function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    CLASS           reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    STRING          reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 64 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)


state 145

    (56) if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .

    PRINT           reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    IF              reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    WHILE           reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    FOR             reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    BREAK           reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    DEF             reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    CLASS           reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RETURN          reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    ID              reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    STRING          reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LBRACKET        reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    NUMBER          reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LPAREN          reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LEN             reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    $end            reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RBRACE          reduce using rule 56 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)


state 146

    (57) else -> ELIF . LPAREN condition RPAREN LBRACE statements RBRACE
    (58) else -> ELIF . LPAREN condition RPAREN LBRACE statements RBRACE else

    LPAREN          shift and go to state 150


state 147

    (59) else -> ELSE . LBRACE statements RBRACE

    LBRACE          shift and go to state 151


state 148

    (61) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 152


state 149

    (63) function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    CLASS           reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    STRING          reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 63 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)


state 150

    (57) else -> ELIF LPAREN . condition RPAREN LBRACE statements RBRACE
    (58) else -> ELIF LPAREN . condition RPAREN LBRACE statements RBRACE else
    (43) condition -> . condition OR join
    (44) condition -> . join
    (45) join -> . join AND equality
    (46) join -> . equality
    (47) equality -> . equality EQ rel
    (48) equality -> . equality NE rel
    (49) equality -> . rel
    (50) rel -> . expr LT expr
    (51) rel -> . expr LE expr
    (52) rel -> . expr GT expr
    (53) rel -> . expr GE expr
    (54) rel -> . expr
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    ID              shift and go to state 25
    LEN             shift and go to state 34

    condition                      shift and go to state 153
    join                           shift and go to state 75
    equality                       shift and go to state 76
    rel                            shift and go to state 77
    expr                           shift and go to state 78
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    variable                       shift and go to state 49
    len                            shift and go to state 32
    call                           shift and go to state 33

state 151

    (59) else -> ELSE LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statements                     shift and go to state 154
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 152

    (61) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    assignment                     shift and go to state 4
    statements                     shift and go to state 155
    statement                      shift and go to state 3
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 153

    (57) else -> ELIF LPAREN condition . RPAREN LBRACE statements RBRACE
    (58) else -> ELIF LPAREN condition . RPAREN LBRACE statements RBRACE else
    (43) condition -> condition . OR join

    RPAREN          shift and go to state 156
    OR              shift and go to state 94


state 154

    (59) else -> ELSE LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACE          shift and go to state 157
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statement                      shift and go to state 35
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 155

    (61) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACE          shift and go to state 158
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    assignment                     shift and go to state 4
    statement                      shift and go to state 35
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 156

    (57) else -> ELIF LPAREN condition RPAREN . LBRACE statements RBRACE
    (58) else -> ELIF LPAREN condition RPAREN . LBRACE statements RBRACE else

    LBRACE          shift and go to state 159


state 157

    (59) else -> ELSE LBRACE statements RBRACE .

    PRINT           reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    IF              reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    WHILE           reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    FOR             reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    BREAK           reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    DEF             reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    CLASS           reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    RETURN          reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    ID              reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    STRING          reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    NUMBER          reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    LPAREN          reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    LEN             reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    $end            reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)
    RBRACE          reduce using rule 59 (else -> ELSE LBRACE statements RBRACE .)


state 158

    (61) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    CLASS           reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    STRING          reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 61 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)


state 159

    (57) else -> ELIF LPAREN condition RPAREN LBRACE . statements RBRACE
    (58) else -> ELIF LPAREN condition RPAREN LBRACE . statements RBRACE else
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statements                     shift and go to state 160
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 160

    (57) else -> ELIF LPAREN condition RPAREN LBRACE statements . RBRACE
    (58) else -> ELIF LPAREN condition RPAREN LBRACE statements . RBRACE else
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . class
    (13) statement -> . return
    (14) assignment -> . variable ASSIGN expr
    (15) assignment -> . variable MINEQUAL expr
    (16) assignment -> . variable PLUSEQUAL expr
    (17) assignment -> . variable DPLUS
    (18) assignment -> . variable DMINUS
    (22) expr -> . expr PLUS term
    (23) expr -> . expr MINUS term
    (24) expr -> . term
    (25) expr -> . string
    (26) expr -> . array
    (39) print -> . PRINT LPAREN exprs RPAREN
    (40) print -> . PRINT LPAREN RPAREN
    (55) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (56) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (60) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (61) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (62) break -> . BREAK
    (63) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (64) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (73) class -> . CLASS ID LBRACE functions RBRACE
    (71) return -> . RETURN
    (72) return -> . RETURN exprs
    (19) variable -> . variable LBRACKET expr RBRACKET
    (20) variable -> . ID DOT ID
    (21) variable -> . ID
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . term EDIVIDE factor
    (30) term -> . factor
    (76) string -> . STRING
    (41) array -> . LBRACKET exprs RBRACKET
    (42) array -> . LBRACKET RBRACKET
    (31) factor -> . variable
    (32) factor -> . NUMBER
    (33) factor -> . len
    (34) factor -> . call
    (35) factor -> . LPAREN expr RPAREN
    (38) len -> . LEN LPAREN variable RPAREN
    (67) call -> . ID LPAREN exprs RPAREN
    (68) call -> . ID LPAREN RPAREN
    (69) call -> . ID DOT ID LPAREN exprs RPAREN
    (70) call -> . ID DOT ID LPAREN RPAREN

    RBRACE          shift and go to state 161
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    DEF             shift and go to state 24
    CLASS           shift and go to state 26
    RETURN          shift and go to state 27
    ID              shift and go to state 25
    STRING          shift and go to state 30
    LBRACKET        shift and go to state 28
    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 19
    LEN             shift and go to state 34

    statement                      shift and go to state 35
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    class                          shift and go to state 12
    return                         shift and go to state 13
    variable                       shift and go to state 14
    term                           shift and go to state 15
    string                         shift and go to state 16
    array                          shift and go to state 17
    factor                         shift and go to state 29
    len                            shift and go to state 32
    call                           shift and go to state 33

state 161

    (57) else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .
    (58) else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE . else
    (57) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE
    (58) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE else
    (59) else -> . ELSE LBRACE statements RBRACE

    PRINT           reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    CLASS           reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    STRING          reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 57 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ELIF            shift and go to state 146
    ELSE            shift and go to state 147

    else                           shift and go to state 162

state 162

    (58) else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .

    PRINT           reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    IF              reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    WHILE           reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    FOR             reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    BREAK           reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    DEF             reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    CLASS           reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RETURN          reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    ID              reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    STRING          reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LBRACKET        reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    NUMBER          reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LPAREN          reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LEN             reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    $end            reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RBRACE          reduce using rule 58 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 14 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 25 resolved as shift
WARNING: shift/reduce conflict for STRING in state 27 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 27 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 27 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 27 resolved as shift
WARNING: shift/reduce conflict for ID in state 27 resolved as shift
WARNING: shift/reduce conflict for LEN in state 27 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 49 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 84 resolved as shift
