Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> assignment
Rule 5     statement -> expr
Rule 6     statement -> print
Rule 7     statement -> if
Rule 8     statement -> while
Rule 9     statement -> for
Rule 10    statement -> break
Rule 11    statement -> function
Rule 12    statement -> return
Rule 13    assignment -> variable ASSIGN expr
Rule 14    assignment -> variable MINEQUAL expr
Rule 15    assignment -> variable PLUSEQUAL expr
Rule 16    assignment -> variable DPLUS
Rule 17    assignment -> variable DMINUS
Rule 18    variable -> variable LBRACKET expr RBRACKET
Rule 19    variable -> ID
Rule 20    expr -> expr PLUS term
Rule 21    expr -> expr MINUS term
Rule 22    expr -> term
Rule 23    expr -> array
Rule 24    term -> term TIMES factor
Rule 25    term -> term DIVIDE factor
Rule 26    term -> term EDIVIDE factor
Rule 27    term -> factor
Rule 28    factor -> variable
Rule 29    factor -> NUMBER
Rule 30    factor -> len
Rule 31    factor -> call
Rule 32    factor -> LPAREN expr RPAREN
Rule 33    exprs -> exprs COMMA expr
Rule 34    exprs -> expr
Rule 35    len -> LEN LPAREN variable RPAREN
Rule 36    print -> PRINT LPAREN exprs RPAREN
Rule 37    print -> PRINT LPAREN RPAREN
Rule 38    array -> LBRACKET exprs RBRACKET
Rule 39    array -> LBRACKET RBRACKET
Rule 40    condition -> condition OR join
Rule 41    condition -> join
Rule 42    join -> join AND equality
Rule 43    join -> equality
Rule 44    equality -> equality EQ rel
Rule 45    equality -> equality NE rel
Rule 46    equality -> rel
Rule 47    rel -> expr LT expr
Rule 48    rel -> expr LE expr
Rule 49    rel -> expr GT expr
Rule 50    rel -> expr GE expr
Rule 51    rel -> expr
Rule 52    if -> IF LPAREN condition RPAREN LBRACE statements RBRACE
Rule 53    if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else
Rule 54    else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE
Rule 55    else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else
Rule 56    else -> ELSE LBRACE statements RBRACE
Rule 57    while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE
Rule 58    for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
Rule 59    break -> BREAK
Rule 60    function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE
Rule 61    function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE
Rule 62    args -> args COMMA ID
Rule 63    args -> ID
Rule 64    call -> ID LPAREN exprs RPAREN
Rule 65    call -> ID LPAREN RPAREN
Rule 66    return -> RETURN
Rule 67    return -> RETURN exprs

Terminals, with rules where they appear

AND                  : 42
ASSIGN               : 13
BREAK                : 59
COMMA                : 33 62
DEF                  : 60 61
DIVIDE               : 25
DMINUS               : 17
DPLUS                : 16
EDIVIDE              : 26
ELIF                 : 54 55
ELSE                 : 56
EQ                   : 44
FOR                  : 58
GE                   : 50
GT                   : 49
ID                   : 19 60 61 62 63 64 65
IF                   : 52 53
LBRACE               : 52 53 54 55 56 57 58 60 61
LBRACKET             : 18 38 39
LE                   : 48
LEN                  : 35
LPAREN               : 32 35 36 37 52 53 54 55 57 58 60 61 64 65
LT                   : 47
MINEQUAL             : 14
MINUS                : 21
NE                   : 45
NUMBER               : 29
OR                   : 40
PLUS                 : 20
PLUSEQUAL            : 15
PRINT                : 36 37
RBRACE               : 52 53 54 55 56 57 58 60 61
RBRACKET             : 18 38 39
RETURN               : 66 67
RPAREN               : 32 35 36 37 52 53 54 55 57 58 60 61 64 65
SEMICOLON            : 58 58
TIMES                : 24
WHILE                : 57
error                : 

Nonterminals, with rules where they appear

args                 : 60 62
array                : 23
assignment           : 4 58 58
break                : 10
call                 : 31
condition            : 40 52 53 54 55 57 58
else                 : 53 55
equality             : 42 43 44 45
expr                 : 5 13 14 15 18 20 21 32 33 34 47 47 48 48 49 49 50 50 51
exprs                : 33 36 38 64 67
factor               : 24 25 26 27
for                  : 9
function             : 11
if                   : 7
join                 : 40 41 42
len                  : 30
print                : 6
program              : 0
rel                  : 44 45 46
return               : 12
statement            : 2 3
statements           : 1 2 52 53 54 55 56 57 58 60 61
term                 : 20 21 22 24 25 26
variable             : 13 14 15 16 17 18 28 35
while                : 8

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    $end            reduce using rule 1 (program -> statements .)
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statement                      shift and go to state 31
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 3

    (3) statements -> statement .

    PRINT           reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    BREAK           reduce using rule 3 (statements -> statement .)
    DEF             reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    ID              reduce using rule 3 (statements -> statement .)
    LBRACKET        reduce using rule 3 (statements -> statement .)
    NUMBER          reduce using rule 3 (statements -> statement .)
    LPAREN          reduce using rule 3 (statements -> statement .)
    LEN             reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)
    RBRACE          reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> assignment .

    PRINT           reduce using rule 4 (statement -> assignment .)
    IF              reduce using rule 4 (statement -> assignment .)
    WHILE           reduce using rule 4 (statement -> assignment .)
    FOR             reduce using rule 4 (statement -> assignment .)
    BREAK           reduce using rule 4 (statement -> assignment .)
    DEF             reduce using rule 4 (statement -> assignment .)
    RETURN          reduce using rule 4 (statement -> assignment .)
    ID              reduce using rule 4 (statement -> assignment .)
    LBRACKET        reduce using rule 4 (statement -> assignment .)
    NUMBER          reduce using rule 4 (statement -> assignment .)
    LPAREN          reduce using rule 4 (statement -> assignment .)
    LEN             reduce using rule 4 (statement -> assignment .)
    $end            reduce using rule 4 (statement -> assignment .)
    RBRACE          reduce using rule 4 (statement -> assignment .)


state 5

    (5) statement -> expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    PRINT           reduce using rule 5 (statement -> expr .)
    IF              reduce using rule 5 (statement -> expr .)
    WHILE           reduce using rule 5 (statement -> expr .)
    FOR             reduce using rule 5 (statement -> expr .)
    BREAK           reduce using rule 5 (statement -> expr .)
    DEF             reduce using rule 5 (statement -> expr .)
    RETURN          reduce using rule 5 (statement -> expr .)
    ID              reduce using rule 5 (statement -> expr .)
    LBRACKET        reduce using rule 5 (statement -> expr .)
    NUMBER          reduce using rule 5 (statement -> expr .)
    LPAREN          reduce using rule 5 (statement -> expr .)
    LEN             reduce using rule 5 (statement -> expr .)
    $end            reduce using rule 5 (statement -> expr .)
    RBRACE          reduce using rule 5 (statement -> expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 6

    (6) statement -> print .

    PRINT           reduce using rule 6 (statement -> print .)
    IF              reduce using rule 6 (statement -> print .)
    WHILE           reduce using rule 6 (statement -> print .)
    FOR             reduce using rule 6 (statement -> print .)
    BREAK           reduce using rule 6 (statement -> print .)
    DEF             reduce using rule 6 (statement -> print .)
    RETURN          reduce using rule 6 (statement -> print .)
    ID              reduce using rule 6 (statement -> print .)
    LBRACKET        reduce using rule 6 (statement -> print .)
    NUMBER          reduce using rule 6 (statement -> print .)
    LPAREN          reduce using rule 6 (statement -> print .)
    LEN             reduce using rule 6 (statement -> print .)
    $end            reduce using rule 6 (statement -> print .)
    RBRACE          reduce using rule 6 (statement -> print .)


state 7

    (7) statement -> if .

    PRINT           reduce using rule 7 (statement -> if .)
    IF              reduce using rule 7 (statement -> if .)
    WHILE           reduce using rule 7 (statement -> if .)
    FOR             reduce using rule 7 (statement -> if .)
    BREAK           reduce using rule 7 (statement -> if .)
    DEF             reduce using rule 7 (statement -> if .)
    RETURN          reduce using rule 7 (statement -> if .)
    ID              reduce using rule 7 (statement -> if .)
    LBRACKET        reduce using rule 7 (statement -> if .)
    NUMBER          reduce using rule 7 (statement -> if .)
    LPAREN          reduce using rule 7 (statement -> if .)
    LEN             reduce using rule 7 (statement -> if .)
    $end            reduce using rule 7 (statement -> if .)
    RBRACE          reduce using rule 7 (statement -> if .)


state 8

    (8) statement -> while .

    PRINT           reduce using rule 8 (statement -> while .)
    IF              reduce using rule 8 (statement -> while .)
    WHILE           reduce using rule 8 (statement -> while .)
    FOR             reduce using rule 8 (statement -> while .)
    BREAK           reduce using rule 8 (statement -> while .)
    DEF             reduce using rule 8 (statement -> while .)
    RETURN          reduce using rule 8 (statement -> while .)
    ID              reduce using rule 8 (statement -> while .)
    LBRACKET        reduce using rule 8 (statement -> while .)
    NUMBER          reduce using rule 8 (statement -> while .)
    LPAREN          reduce using rule 8 (statement -> while .)
    LEN             reduce using rule 8 (statement -> while .)
    $end            reduce using rule 8 (statement -> while .)
    RBRACE          reduce using rule 8 (statement -> while .)


state 9

    (9) statement -> for .

    PRINT           reduce using rule 9 (statement -> for .)
    IF              reduce using rule 9 (statement -> for .)
    WHILE           reduce using rule 9 (statement -> for .)
    FOR             reduce using rule 9 (statement -> for .)
    BREAK           reduce using rule 9 (statement -> for .)
    DEF             reduce using rule 9 (statement -> for .)
    RETURN          reduce using rule 9 (statement -> for .)
    ID              reduce using rule 9 (statement -> for .)
    LBRACKET        reduce using rule 9 (statement -> for .)
    NUMBER          reduce using rule 9 (statement -> for .)
    LPAREN          reduce using rule 9 (statement -> for .)
    LEN             reduce using rule 9 (statement -> for .)
    $end            reduce using rule 9 (statement -> for .)
    RBRACE          reduce using rule 9 (statement -> for .)


state 10

    (10) statement -> break .

    PRINT           reduce using rule 10 (statement -> break .)
    IF              reduce using rule 10 (statement -> break .)
    WHILE           reduce using rule 10 (statement -> break .)
    FOR             reduce using rule 10 (statement -> break .)
    BREAK           reduce using rule 10 (statement -> break .)
    DEF             reduce using rule 10 (statement -> break .)
    RETURN          reduce using rule 10 (statement -> break .)
    ID              reduce using rule 10 (statement -> break .)
    LBRACKET        reduce using rule 10 (statement -> break .)
    NUMBER          reduce using rule 10 (statement -> break .)
    LPAREN          reduce using rule 10 (statement -> break .)
    LEN             reduce using rule 10 (statement -> break .)
    $end            reduce using rule 10 (statement -> break .)
    RBRACE          reduce using rule 10 (statement -> break .)


state 11

    (11) statement -> function .

    PRINT           reduce using rule 11 (statement -> function .)
    IF              reduce using rule 11 (statement -> function .)
    WHILE           reduce using rule 11 (statement -> function .)
    FOR             reduce using rule 11 (statement -> function .)
    BREAK           reduce using rule 11 (statement -> function .)
    DEF             reduce using rule 11 (statement -> function .)
    RETURN          reduce using rule 11 (statement -> function .)
    ID              reduce using rule 11 (statement -> function .)
    LBRACKET        reduce using rule 11 (statement -> function .)
    NUMBER          reduce using rule 11 (statement -> function .)
    LPAREN          reduce using rule 11 (statement -> function .)
    LEN             reduce using rule 11 (statement -> function .)
    $end            reduce using rule 11 (statement -> function .)
    RBRACE          reduce using rule 11 (statement -> function .)


state 12

    (12) statement -> return .

    PRINT           reduce using rule 12 (statement -> return .)
    IF              reduce using rule 12 (statement -> return .)
    WHILE           reduce using rule 12 (statement -> return .)
    FOR             reduce using rule 12 (statement -> return .)
    BREAK           reduce using rule 12 (statement -> return .)
    DEF             reduce using rule 12 (statement -> return .)
    RETURN          reduce using rule 12 (statement -> return .)
    ID              reduce using rule 12 (statement -> return .)
    LBRACKET        reduce using rule 12 (statement -> return .)
    NUMBER          reduce using rule 12 (statement -> return .)
    LPAREN          reduce using rule 12 (statement -> return .)
    LEN             reduce using rule 12 (statement -> return .)
    $end            reduce using rule 12 (statement -> return .)
    RBRACE          reduce using rule 12 (statement -> return .)


state 13

    (13) assignment -> variable . ASSIGN expr
    (14) assignment -> variable . MINEQUAL expr
    (15) assignment -> variable . PLUSEQUAL expr
    (16) assignment -> variable . DPLUS
    (17) assignment -> variable . DMINUS
    (18) variable -> variable . LBRACKET expr RBRACKET
    (28) factor -> variable .

  ! shift/reduce conflict for LBRACKET resolved as shift
    ASSIGN          shift and go to state 34
    MINEQUAL        shift and go to state 35
    PLUSEQUAL       shift and go to state 36
    DPLUS           shift and go to state 37
    DMINUS          shift and go to state 38
    LBRACKET        shift and go to state 39
    TIMES           reduce using rule 28 (factor -> variable .)
    DIVIDE          reduce using rule 28 (factor -> variable .)
    EDIVIDE         reduce using rule 28 (factor -> variable .)
    PLUS            reduce using rule 28 (factor -> variable .)
    MINUS           reduce using rule 28 (factor -> variable .)
    PRINT           reduce using rule 28 (factor -> variable .)
    IF              reduce using rule 28 (factor -> variable .)
    WHILE           reduce using rule 28 (factor -> variable .)
    FOR             reduce using rule 28 (factor -> variable .)
    BREAK           reduce using rule 28 (factor -> variable .)
    DEF             reduce using rule 28 (factor -> variable .)
    RETURN          reduce using rule 28 (factor -> variable .)
    ID              reduce using rule 28 (factor -> variable .)
    NUMBER          reduce using rule 28 (factor -> variable .)
    LPAREN          reduce using rule 28 (factor -> variable .)
    LEN             reduce using rule 28 (factor -> variable .)
    $end            reduce using rule 28 (factor -> variable .)
    RBRACE          reduce using rule 28 (factor -> variable .)

  ! LBRACKET        [ reduce using rule 28 (factor -> variable .) ]


state 14

    (22) expr -> term .
    (24) term -> term . TIMES factor
    (25) term -> term . DIVIDE factor
    (26) term -> term . EDIVIDE factor

    PLUS            reduce using rule 22 (expr -> term .)
    MINUS           reduce using rule 22 (expr -> term .)
    PRINT           reduce using rule 22 (expr -> term .)
    IF              reduce using rule 22 (expr -> term .)
    WHILE           reduce using rule 22 (expr -> term .)
    FOR             reduce using rule 22 (expr -> term .)
    BREAK           reduce using rule 22 (expr -> term .)
    DEF             reduce using rule 22 (expr -> term .)
    RETURN          reduce using rule 22 (expr -> term .)
    ID              reduce using rule 22 (expr -> term .)
    LBRACKET        reduce using rule 22 (expr -> term .)
    NUMBER          reduce using rule 22 (expr -> term .)
    LPAREN          reduce using rule 22 (expr -> term .)
    LEN             reduce using rule 22 (expr -> term .)
    $end            reduce using rule 22 (expr -> term .)
    RPAREN          reduce using rule 22 (expr -> term .)
    COMMA           reduce using rule 22 (expr -> term .)
    RBRACE          reduce using rule 22 (expr -> term .)
    RBRACKET        reduce using rule 22 (expr -> term .)
    SEMICOLON       reduce using rule 22 (expr -> term .)
    LT              reduce using rule 22 (expr -> term .)
    LE              reduce using rule 22 (expr -> term .)
    GT              reduce using rule 22 (expr -> term .)
    GE              reduce using rule 22 (expr -> term .)
    EQ              reduce using rule 22 (expr -> term .)
    NE              reduce using rule 22 (expr -> term .)
    AND             reduce using rule 22 (expr -> term .)
    OR              reduce using rule 22 (expr -> term .)
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41
    EDIVIDE         shift and go to state 42


state 15

    (23) expr -> array .

    PLUS            reduce using rule 23 (expr -> array .)
    MINUS           reduce using rule 23 (expr -> array .)
    PRINT           reduce using rule 23 (expr -> array .)
    IF              reduce using rule 23 (expr -> array .)
    WHILE           reduce using rule 23 (expr -> array .)
    FOR             reduce using rule 23 (expr -> array .)
    BREAK           reduce using rule 23 (expr -> array .)
    DEF             reduce using rule 23 (expr -> array .)
    RETURN          reduce using rule 23 (expr -> array .)
    ID              reduce using rule 23 (expr -> array .)
    LBRACKET        reduce using rule 23 (expr -> array .)
    NUMBER          reduce using rule 23 (expr -> array .)
    LPAREN          reduce using rule 23 (expr -> array .)
    LEN             reduce using rule 23 (expr -> array .)
    $end            reduce using rule 23 (expr -> array .)
    RPAREN          reduce using rule 23 (expr -> array .)
    COMMA           reduce using rule 23 (expr -> array .)
    RBRACE          reduce using rule 23 (expr -> array .)
    RBRACKET        reduce using rule 23 (expr -> array .)
    SEMICOLON       reduce using rule 23 (expr -> array .)
    LT              reduce using rule 23 (expr -> array .)
    LE              reduce using rule 23 (expr -> array .)
    GT              reduce using rule 23 (expr -> array .)
    GE              reduce using rule 23 (expr -> array .)
    EQ              reduce using rule 23 (expr -> array .)
    NE              reduce using rule 23 (expr -> array .)
    AND             reduce using rule 23 (expr -> array .)
    OR              reduce using rule 23 (expr -> array .)


state 16

    (36) print -> PRINT . LPAREN exprs RPAREN
    (37) print -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 43


state 17

    (32) factor -> LPAREN . expr RPAREN
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    expr                           shift and go to state 44
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 18

    (52) if -> IF . LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> IF . LPAREN condition RPAREN LBRACE statements RBRACE else

    LPAREN          shift and go to state 46


state 19

    (57) while -> WHILE . LPAREN condition RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 47


state 20

    (58) for -> FOR . LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 48


state 21

    (59) break -> BREAK .

    PRINT           reduce using rule 59 (break -> BREAK .)
    IF              reduce using rule 59 (break -> BREAK .)
    WHILE           reduce using rule 59 (break -> BREAK .)
    FOR             reduce using rule 59 (break -> BREAK .)
    BREAK           reduce using rule 59 (break -> BREAK .)
    DEF             reduce using rule 59 (break -> BREAK .)
    RETURN          reduce using rule 59 (break -> BREAK .)
    ID              reduce using rule 59 (break -> BREAK .)
    LBRACKET        reduce using rule 59 (break -> BREAK .)
    NUMBER          reduce using rule 59 (break -> BREAK .)
    LPAREN          reduce using rule 59 (break -> BREAK .)
    LEN             reduce using rule 59 (break -> BREAK .)
    $end            reduce using rule 59 (break -> BREAK .)
    RBRACE          reduce using rule 59 (break -> BREAK .)


state 22

    (60) function -> DEF . ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> DEF . ID LPAREN RPAREN LBRACE statements RBRACE

    ID              shift and go to state 49


state 23

    (19) variable -> ID .
    (64) call -> ID . LPAREN exprs RPAREN
    (65) call -> ID . LPAREN RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    ASSIGN          reduce using rule 19 (variable -> ID .)
    MINEQUAL        reduce using rule 19 (variable -> ID .)
    PLUSEQUAL       reduce using rule 19 (variable -> ID .)
    DPLUS           reduce using rule 19 (variable -> ID .)
    DMINUS          reduce using rule 19 (variable -> ID .)
    LBRACKET        reduce using rule 19 (variable -> ID .)
    TIMES           reduce using rule 19 (variable -> ID .)
    DIVIDE          reduce using rule 19 (variable -> ID .)
    EDIVIDE         reduce using rule 19 (variable -> ID .)
    PLUS            reduce using rule 19 (variable -> ID .)
    MINUS           reduce using rule 19 (variable -> ID .)
    PRINT           reduce using rule 19 (variable -> ID .)
    IF              reduce using rule 19 (variable -> ID .)
    WHILE           reduce using rule 19 (variable -> ID .)
    FOR             reduce using rule 19 (variable -> ID .)
    BREAK           reduce using rule 19 (variable -> ID .)
    DEF             reduce using rule 19 (variable -> ID .)
    RETURN          reduce using rule 19 (variable -> ID .)
    ID              reduce using rule 19 (variable -> ID .)
    NUMBER          reduce using rule 19 (variable -> ID .)
    LEN             reduce using rule 19 (variable -> ID .)
    $end            reduce using rule 19 (variable -> ID .)
    RPAREN          reduce using rule 19 (variable -> ID .)
    COMMA           reduce using rule 19 (variable -> ID .)
    RBRACE          reduce using rule 19 (variable -> ID .)
    RBRACKET        reduce using rule 19 (variable -> ID .)
    SEMICOLON       reduce using rule 19 (variable -> ID .)
    LT              reduce using rule 19 (variable -> ID .)
    LE              reduce using rule 19 (variable -> ID .)
    GT              reduce using rule 19 (variable -> ID .)
    GE              reduce using rule 19 (variable -> ID .)
    EQ              reduce using rule 19 (variable -> ID .)
    NE              reduce using rule 19 (variable -> ID .)
    AND             reduce using rule 19 (variable -> ID .)
    OR              reduce using rule 19 (variable -> ID .)
    LPAREN          shift and go to state 50

  ! LPAREN          [ reduce using rule 19 (variable -> ID .) ]


state 24

    (66) return -> RETURN .
    (67) return -> RETURN . exprs
    (33) exprs -> . exprs COMMA expr
    (34) exprs -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LEN resolved as shift
    PRINT           reduce using rule 66 (return -> RETURN .)
    IF              reduce using rule 66 (return -> RETURN .)
    WHILE           reduce using rule 66 (return -> RETURN .)
    FOR             reduce using rule 66 (return -> RETURN .)
    BREAK           reduce using rule 66 (return -> RETURN .)
    DEF             reduce using rule 66 (return -> RETURN .)
    RETURN          reduce using rule 66 (return -> RETURN .)
    $end            reduce using rule 66 (return -> RETURN .)
    RBRACE          reduce using rule 66 (return -> RETURN .)
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

  ! ID              [ reduce using rule 66 (return -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 66 (return -> RETURN .) ]
  ! NUMBER          [ reduce using rule 66 (return -> RETURN .) ]
  ! LPAREN          [ reduce using rule 66 (return -> RETURN .) ]
  ! LEN             [ reduce using rule 66 (return -> RETURN .) ]

    exprs                          shift and go to state 51
    expr                           shift and go to state 52
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 25

    (38) array -> LBRACKET . exprs RBRACKET
    (39) array -> LBRACKET . RBRACKET
    (33) exprs -> . exprs COMMA expr
    (34) exprs -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACKET        shift and go to state 54
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    exprs                          shift and go to state 53
    expr                           shift and go to state 52
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 26

    (27) term -> factor .

    TIMES           reduce using rule 27 (term -> factor .)
    DIVIDE          reduce using rule 27 (term -> factor .)
    EDIVIDE         reduce using rule 27 (term -> factor .)
    PLUS            reduce using rule 27 (term -> factor .)
    MINUS           reduce using rule 27 (term -> factor .)
    PRINT           reduce using rule 27 (term -> factor .)
    IF              reduce using rule 27 (term -> factor .)
    WHILE           reduce using rule 27 (term -> factor .)
    FOR             reduce using rule 27 (term -> factor .)
    BREAK           reduce using rule 27 (term -> factor .)
    DEF             reduce using rule 27 (term -> factor .)
    RETURN          reduce using rule 27 (term -> factor .)
    ID              reduce using rule 27 (term -> factor .)
    LBRACKET        reduce using rule 27 (term -> factor .)
    NUMBER          reduce using rule 27 (term -> factor .)
    LPAREN          reduce using rule 27 (term -> factor .)
    LEN             reduce using rule 27 (term -> factor .)
    $end            reduce using rule 27 (term -> factor .)
    RPAREN          reduce using rule 27 (term -> factor .)
    COMMA           reduce using rule 27 (term -> factor .)
    RBRACE          reduce using rule 27 (term -> factor .)
    RBRACKET        reduce using rule 27 (term -> factor .)
    SEMICOLON       reduce using rule 27 (term -> factor .)
    LT              reduce using rule 27 (term -> factor .)
    LE              reduce using rule 27 (term -> factor .)
    GT              reduce using rule 27 (term -> factor .)
    GE              reduce using rule 27 (term -> factor .)
    EQ              reduce using rule 27 (term -> factor .)
    NE              reduce using rule 27 (term -> factor .)
    AND             reduce using rule 27 (term -> factor .)
    OR              reduce using rule 27 (term -> factor .)


state 27

    (29) factor -> NUMBER .

    TIMES           reduce using rule 29 (factor -> NUMBER .)
    DIVIDE          reduce using rule 29 (factor -> NUMBER .)
    EDIVIDE         reduce using rule 29 (factor -> NUMBER .)
    PLUS            reduce using rule 29 (factor -> NUMBER .)
    MINUS           reduce using rule 29 (factor -> NUMBER .)
    PRINT           reduce using rule 29 (factor -> NUMBER .)
    IF              reduce using rule 29 (factor -> NUMBER .)
    WHILE           reduce using rule 29 (factor -> NUMBER .)
    FOR             reduce using rule 29 (factor -> NUMBER .)
    BREAK           reduce using rule 29 (factor -> NUMBER .)
    DEF             reduce using rule 29 (factor -> NUMBER .)
    RETURN          reduce using rule 29 (factor -> NUMBER .)
    ID              reduce using rule 29 (factor -> NUMBER .)
    LBRACKET        reduce using rule 29 (factor -> NUMBER .)
    NUMBER          reduce using rule 29 (factor -> NUMBER .)
    LPAREN          reduce using rule 29 (factor -> NUMBER .)
    LEN             reduce using rule 29 (factor -> NUMBER .)
    $end            reduce using rule 29 (factor -> NUMBER .)
    RPAREN          reduce using rule 29 (factor -> NUMBER .)
    COMMA           reduce using rule 29 (factor -> NUMBER .)
    RBRACE          reduce using rule 29 (factor -> NUMBER .)
    RBRACKET        reduce using rule 29 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 29 (factor -> NUMBER .)
    LT              reduce using rule 29 (factor -> NUMBER .)
    LE              reduce using rule 29 (factor -> NUMBER .)
    GT              reduce using rule 29 (factor -> NUMBER .)
    GE              reduce using rule 29 (factor -> NUMBER .)
    EQ              reduce using rule 29 (factor -> NUMBER .)
    NE              reduce using rule 29 (factor -> NUMBER .)
    AND             reduce using rule 29 (factor -> NUMBER .)
    OR              reduce using rule 29 (factor -> NUMBER .)


state 28

    (30) factor -> len .

    TIMES           reduce using rule 30 (factor -> len .)
    DIVIDE          reduce using rule 30 (factor -> len .)
    EDIVIDE         reduce using rule 30 (factor -> len .)
    PLUS            reduce using rule 30 (factor -> len .)
    MINUS           reduce using rule 30 (factor -> len .)
    PRINT           reduce using rule 30 (factor -> len .)
    IF              reduce using rule 30 (factor -> len .)
    WHILE           reduce using rule 30 (factor -> len .)
    FOR             reduce using rule 30 (factor -> len .)
    BREAK           reduce using rule 30 (factor -> len .)
    DEF             reduce using rule 30 (factor -> len .)
    RETURN          reduce using rule 30 (factor -> len .)
    ID              reduce using rule 30 (factor -> len .)
    LBRACKET        reduce using rule 30 (factor -> len .)
    NUMBER          reduce using rule 30 (factor -> len .)
    LPAREN          reduce using rule 30 (factor -> len .)
    LEN             reduce using rule 30 (factor -> len .)
    $end            reduce using rule 30 (factor -> len .)
    RPAREN          reduce using rule 30 (factor -> len .)
    COMMA           reduce using rule 30 (factor -> len .)
    RBRACE          reduce using rule 30 (factor -> len .)
    RBRACKET        reduce using rule 30 (factor -> len .)
    SEMICOLON       reduce using rule 30 (factor -> len .)
    LT              reduce using rule 30 (factor -> len .)
    LE              reduce using rule 30 (factor -> len .)
    GT              reduce using rule 30 (factor -> len .)
    GE              reduce using rule 30 (factor -> len .)
    EQ              reduce using rule 30 (factor -> len .)
    NE              reduce using rule 30 (factor -> len .)
    AND             reduce using rule 30 (factor -> len .)
    OR              reduce using rule 30 (factor -> len .)


state 29

    (31) factor -> call .

    TIMES           reduce using rule 31 (factor -> call .)
    DIVIDE          reduce using rule 31 (factor -> call .)
    EDIVIDE         reduce using rule 31 (factor -> call .)
    PLUS            reduce using rule 31 (factor -> call .)
    MINUS           reduce using rule 31 (factor -> call .)
    PRINT           reduce using rule 31 (factor -> call .)
    IF              reduce using rule 31 (factor -> call .)
    WHILE           reduce using rule 31 (factor -> call .)
    FOR             reduce using rule 31 (factor -> call .)
    BREAK           reduce using rule 31 (factor -> call .)
    DEF             reduce using rule 31 (factor -> call .)
    RETURN          reduce using rule 31 (factor -> call .)
    ID              reduce using rule 31 (factor -> call .)
    LBRACKET        reduce using rule 31 (factor -> call .)
    NUMBER          reduce using rule 31 (factor -> call .)
    LPAREN          reduce using rule 31 (factor -> call .)
    LEN             reduce using rule 31 (factor -> call .)
    $end            reduce using rule 31 (factor -> call .)
    RPAREN          reduce using rule 31 (factor -> call .)
    COMMA           reduce using rule 31 (factor -> call .)
    RBRACE          reduce using rule 31 (factor -> call .)
    RBRACKET        reduce using rule 31 (factor -> call .)
    SEMICOLON       reduce using rule 31 (factor -> call .)
    LT              reduce using rule 31 (factor -> call .)
    LE              reduce using rule 31 (factor -> call .)
    GT              reduce using rule 31 (factor -> call .)
    GE              reduce using rule 31 (factor -> call .)
    EQ              reduce using rule 31 (factor -> call .)
    NE              reduce using rule 31 (factor -> call .)
    AND             reduce using rule 31 (factor -> call .)
    OR              reduce using rule 31 (factor -> call .)


state 30

    (35) len -> LEN . LPAREN variable RPAREN

    LPAREN          shift and go to state 55


state 31

    (2) statements -> statements statement .

    PRINT           reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    WHILE           reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    BREAK           reduce using rule 2 (statements -> statements statement .)
    DEF             reduce using rule 2 (statements -> statements statement .)
    RETURN          reduce using rule 2 (statements -> statements statement .)
    ID              reduce using rule 2 (statements -> statements statement .)
    LBRACKET        reduce using rule 2 (statements -> statements statement .)
    NUMBER          reduce using rule 2 (statements -> statements statement .)
    LPAREN          reduce using rule 2 (statements -> statements statement .)
    LEN             reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)
    RBRACE          reduce using rule 2 (statements -> statements statement .)


state 32

    (20) expr -> expr PLUS . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    term                           shift and go to state 56
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 33

    (21) expr -> expr MINUS . term
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    term                           shift and go to state 57
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 34

    (13) assignment -> variable ASSIGN . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    variable                       shift and go to state 45
    expr                           shift and go to state 58
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 35

    (14) assignment -> variable MINEQUAL . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    variable                       shift and go to state 45
    expr                           shift and go to state 59
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 36

    (15) assignment -> variable PLUSEQUAL . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    variable                       shift and go to state 45
    expr                           shift and go to state 60
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 37

    (16) assignment -> variable DPLUS .

    PRINT           reduce using rule 16 (assignment -> variable DPLUS .)
    IF              reduce using rule 16 (assignment -> variable DPLUS .)
    WHILE           reduce using rule 16 (assignment -> variable DPLUS .)
    FOR             reduce using rule 16 (assignment -> variable DPLUS .)
    BREAK           reduce using rule 16 (assignment -> variable DPLUS .)
    DEF             reduce using rule 16 (assignment -> variable DPLUS .)
    RETURN          reduce using rule 16 (assignment -> variable DPLUS .)
    ID              reduce using rule 16 (assignment -> variable DPLUS .)
    LBRACKET        reduce using rule 16 (assignment -> variable DPLUS .)
    NUMBER          reduce using rule 16 (assignment -> variable DPLUS .)
    LPAREN          reduce using rule 16 (assignment -> variable DPLUS .)
    LEN             reduce using rule 16 (assignment -> variable DPLUS .)
    $end            reduce using rule 16 (assignment -> variable DPLUS .)
    SEMICOLON       reduce using rule 16 (assignment -> variable DPLUS .)
    RBRACE          reduce using rule 16 (assignment -> variable DPLUS .)
    RPAREN          reduce using rule 16 (assignment -> variable DPLUS .)


state 38

    (17) assignment -> variable DMINUS .

    PRINT           reduce using rule 17 (assignment -> variable DMINUS .)
    IF              reduce using rule 17 (assignment -> variable DMINUS .)
    WHILE           reduce using rule 17 (assignment -> variable DMINUS .)
    FOR             reduce using rule 17 (assignment -> variable DMINUS .)
    BREAK           reduce using rule 17 (assignment -> variable DMINUS .)
    DEF             reduce using rule 17 (assignment -> variable DMINUS .)
    RETURN          reduce using rule 17 (assignment -> variable DMINUS .)
    ID              reduce using rule 17 (assignment -> variable DMINUS .)
    LBRACKET        reduce using rule 17 (assignment -> variable DMINUS .)
    NUMBER          reduce using rule 17 (assignment -> variable DMINUS .)
    LPAREN          reduce using rule 17 (assignment -> variable DMINUS .)
    LEN             reduce using rule 17 (assignment -> variable DMINUS .)
    $end            reduce using rule 17 (assignment -> variable DMINUS .)
    SEMICOLON       reduce using rule 17 (assignment -> variable DMINUS .)
    RBRACE          reduce using rule 17 (assignment -> variable DMINUS .)
    RPAREN          reduce using rule 17 (assignment -> variable DMINUS .)


state 39

    (18) variable -> variable LBRACKET . expr RBRACKET
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    variable                       shift and go to state 45
    expr                           shift and go to state 61
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 40

    (24) term -> term TIMES . factor
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    factor                         shift and go to state 62
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 41

    (25) term -> term DIVIDE . factor
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    factor                         shift and go to state 63
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 42

    (26) term -> term EDIVIDE . factor
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    factor                         shift and go to state 64
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 43

    (36) print -> PRINT LPAREN . exprs RPAREN
    (37) print -> PRINT LPAREN . RPAREN
    (33) exprs -> . exprs COMMA expr
    (34) exprs -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 66
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    exprs                          shift and go to state 65
    expr                           shift and go to state 52
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 44

    (32) factor -> LPAREN expr . RPAREN
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    RPAREN          shift and go to state 67
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 45

    (28) factor -> variable .
    (18) variable -> variable . LBRACKET expr RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 28 (factor -> variable .)
    DIVIDE          reduce using rule 28 (factor -> variable .)
    EDIVIDE         reduce using rule 28 (factor -> variable .)
    RPAREN          reduce using rule 28 (factor -> variable .)
    PLUS            reduce using rule 28 (factor -> variable .)
    MINUS           reduce using rule 28 (factor -> variable .)
    COMMA           reduce using rule 28 (factor -> variable .)
    PRINT           reduce using rule 28 (factor -> variable .)
    IF              reduce using rule 28 (factor -> variable .)
    WHILE           reduce using rule 28 (factor -> variable .)
    FOR             reduce using rule 28 (factor -> variable .)
    BREAK           reduce using rule 28 (factor -> variable .)
    DEF             reduce using rule 28 (factor -> variable .)
    RETURN          reduce using rule 28 (factor -> variable .)
    ID              reduce using rule 28 (factor -> variable .)
    NUMBER          reduce using rule 28 (factor -> variable .)
    LPAREN          reduce using rule 28 (factor -> variable .)
    LEN             reduce using rule 28 (factor -> variable .)
    $end            reduce using rule 28 (factor -> variable .)
    RBRACE          reduce using rule 28 (factor -> variable .)
    RBRACKET        reduce using rule 28 (factor -> variable .)
    SEMICOLON       reduce using rule 28 (factor -> variable .)
    LT              reduce using rule 28 (factor -> variable .)
    LE              reduce using rule 28 (factor -> variable .)
    GT              reduce using rule 28 (factor -> variable .)
    GE              reduce using rule 28 (factor -> variable .)
    EQ              reduce using rule 28 (factor -> variable .)
    NE              reduce using rule 28 (factor -> variable .)
    AND             reduce using rule 28 (factor -> variable .)
    OR              reduce using rule 28 (factor -> variable .)
    LBRACKET        shift and go to state 39

  ! LBRACKET        [ reduce using rule 28 (factor -> variable .) ]


state 46

    (52) if -> IF LPAREN . condition RPAREN LBRACE statements RBRACE
    (53) if -> IF LPAREN . condition RPAREN LBRACE statements RBRACE else
    (40) condition -> . condition OR join
    (41) condition -> . join
    (42) join -> . join AND equality
    (43) join -> . equality
    (44) equality -> . equality EQ rel
    (45) equality -> . equality NE rel
    (46) equality -> . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    condition                      shift and go to state 68
    join                           shift and go to state 69
    equality                       shift and go to state 70
    rel                            shift and go to state 71
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 47

    (57) while -> WHILE LPAREN . condition RPAREN LBRACE statements RBRACE
    (40) condition -> . condition OR join
    (41) condition -> . join
    (42) join -> . join AND equality
    (43) join -> . equality
    (44) equality -> . equality EQ rel
    (45) equality -> . equality NE rel
    (46) equality -> . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    condition                      shift and go to state 73
    join                           shift and go to state 69
    equality                       shift and go to state 70
    rel                            shift and go to state 71
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 48

    (58) for -> FOR LPAREN . assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID

    ID              shift and go to state 76

    assignment                     shift and go to state 74
    variable                       shift and go to state 75

state 49

    (60) function -> DEF ID . LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> DEF ID . LPAREN RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 77


state 50

    (64) call -> ID LPAREN . exprs RPAREN
    (65) call -> ID LPAREN . RPAREN
    (33) exprs -> . exprs COMMA expr
    (34) exprs -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 79
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    exprs                          shift and go to state 78
    expr                           shift and go to state 52
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 51

    (67) return -> RETURN exprs .
    (33) exprs -> exprs . COMMA expr

    PRINT           reduce using rule 67 (return -> RETURN exprs .)
    IF              reduce using rule 67 (return -> RETURN exprs .)
    WHILE           reduce using rule 67 (return -> RETURN exprs .)
    FOR             reduce using rule 67 (return -> RETURN exprs .)
    BREAK           reduce using rule 67 (return -> RETURN exprs .)
    DEF             reduce using rule 67 (return -> RETURN exprs .)
    RETURN          reduce using rule 67 (return -> RETURN exprs .)
    ID              reduce using rule 67 (return -> RETURN exprs .)
    LBRACKET        reduce using rule 67 (return -> RETURN exprs .)
    NUMBER          reduce using rule 67 (return -> RETURN exprs .)
    LPAREN          reduce using rule 67 (return -> RETURN exprs .)
    LEN             reduce using rule 67 (return -> RETURN exprs .)
    $end            reduce using rule 67 (return -> RETURN exprs .)
    RBRACE          reduce using rule 67 (return -> RETURN exprs .)
    COMMA           shift and go to state 80


state 52

    (34) exprs -> expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    COMMA           reduce using rule 34 (exprs -> expr .)
    PRINT           reduce using rule 34 (exprs -> expr .)
    IF              reduce using rule 34 (exprs -> expr .)
    WHILE           reduce using rule 34 (exprs -> expr .)
    FOR             reduce using rule 34 (exprs -> expr .)
    BREAK           reduce using rule 34 (exprs -> expr .)
    DEF             reduce using rule 34 (exprs -> expr .)
    RETURN          reduce using rule 34 (exprs -> expr .)
    ID              reduce using rule 34 (exprs -> expr .)
    LBRACKET        reduce using rule 34 (exprs -> expr .)
    NUMBER          reduce using rule 34 (exprs -> expr .)
    LPAREN          reduce using rule 34 (exprs -> expr .)
    LEN             reduce using rule 34 (exprs -> expr .)
    $end            reduce using rule 34 (exprs -> expr .)
    RBRACE          reduce using rule 34 (exprs -> expr .)
    RBRACKET        reduce using rule 34 (exprs -> expr .)
    RPAREN          reduce using rule 34 (exprs -> expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 53

    (38) array -> LBRACKET exprs . RBRACKET
    (33) exprs -> exprs . COMMA expr

    RBRACKET        shift and go to state 81
    COMMA           shift and go to state 80


state 54

    (39) array -> LBRACKET RBRACKET .

    PLUS            reduce using rule 39 (array -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 39 (array -> LBRACKET RBRACKET .)
    PRINT           reduce using rule 39 (array -> LBRACKET RBRACKET .)
    IF              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 39 (array -> LBRACKET RBRACKET .)
    FOR             reduce using rule 39 (array -> LBRACKET RBRACKET .)
    BREAK           reduce using rule 39 (array -> LBRACKET RBRACKET .)
    DEF             reduce using rule 39 (array -> LBRACKET RBRACKET .)
    RETURN          reduce using rule 39 (array -> LBRACKET RBRACKET .)
    ID              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 39 (array -> LBRACKET RBRACKET .)
    NUMBER          reduce using rule 39 (array -> LBRACKET RBRACKET .)
    LPAREN          reduce using rule 39 (array -> LBRACKET RBRACKET .)
    LEN             reduce using rule 39 (array -> LBRACKET RBRACKET .)
    $end            reduce using rule 39 (array -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 39 (array -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 39 (array -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 39 (array -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 39 (array -> LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 39 (array -> LBRACKET RBRACKET .)
    LT              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    LE              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    GT              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    GE              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    EQ              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    NE              reduce using rule 39 (array -> LBRACKET RBRACKET .)
    AND             reduce using rule 39 (array -> LBRACKET RBRACKET .)
    OR              reduce using rule 39 (array -> LBRACKET RBRACKET .)


state 55

    (35) len -> LEN LPAREN . variable RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID

    ID              shift and go to state 76

    variable                       shift and go to state 82

state 56

    (20) expr -> expr PLUS term .
    (24) term -> term . TIMES factor
    (25) term -> term . DIVIDE factor
    (26) term -> term . EDIVIDE factor

    PLUS            reduce using rule 20 (expr -> expr PLUS term .)
    MINUS           reduce using rule 20 (expr -> expr PLUS term .)
    PRINT           reduce using rule 20 (expr -> expr PLUS term .)
    IF              reduce using rule 20 (expr -> expr PLUS term .)
    WHILE           reduce using rule 20 (expr -> expr PLUS term .)
    FOR             reduce using rule 20 (expr -> expr PLUS term .)
    BREAK           reduce using rule 20 (expr -> expr PLUS term .)
    DEF             reduce using rule 20 (expr -> expr PLUS term .)
    RETURN          reduce using rule 20 (expr -> expr PLUS term .)
    ID              reduce using rule 20 (expr -> expr PLUS term .)
    LBRACKET        reduce using rule 20 (expr -> expr PLUS term .)
    NUMBER          reduce using rule 20 (expr -> expr PLUS term .)
    LPAREN          reduce using rule 20 (expr -> expr PLUS term .)
    LEN             reduce using rule 20 (expr -> expr PLUS term .)
    $end            reduce using rule 20 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 20 (expr -> expr PLUS term .)
    COMMA           reduce using rule 20 (expr -> expr PLUS term .)
    RBRACE          reduce using rule 20 (expr -> expr PLUS term .)
    RBRACKET        reduce using rule 20 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 20 (expr -> expr PLUS term .)
    LT              reduce using rule 20 (expr -> expr PLUS term .)
    LE              reduce using rule 20 (expr -> expr PLUS term .)
    GT              reduce using rule 20 (expr -> expr PLUS term .)
    GE              reduce using rule 20 (expr -> expr PLUS term .)
    EQ              reduce using rule 20 (expr -> expr PLUS term .)
    NE              reduce using rule 20 (expr -> expr PLUS term .)
    AND             reduce using rule 20 (expr -> expr PLUS term .)
    OR              reduce using rule 20 (expr -> expr PLUS term .)
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41
    EDIVIDE         shift and go to state 42


state 57

    (21) expr -> expr MINUS term .
    (24) term -> term . TIMES factor
    (25) term -> term . DIVIDE factor
    (26) term -> term . EDIVIDE factor

    PLUS            reduce using rule 21 (expr -> expr MINUS term .)
    MINUS           reduce using rule 21 (expr -> expr MINUS term .)
    PRINT           reduce using rule 21 (expr -> expr MINUS term .)
    IF              reduce using rule 21 (expr -> expr MINUS term .)
    WHILE           reduce using rule 21 (expr -> expr MINUS term .)
    FOR             reduce using rule 21 (expr -> expr MINUS term .)
    BREAK           reduce using rule 21 (expr -> expr MINUS term .)
    DEF             reduce using rule 21 (expr -> expr MINUS term .)
    RETURN          reduce using rule 21 (expr -> expr MINUS term .)
    ID              reduce using rule 21 (expr -> expr MINUS term .)
    LBRACKET        reduce using rule 21 (expr -> expr MINUS term .)
    NUMBER          reduce using rule 21 (expr -> expr MINUS term .)
    LPAREN          reduce using rule 21 (expr -> expr MINUS term .)
    LEN             reduce using rule 21 (expr -> expr MINUS term .)
    $end            reduce using rule 21 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 21 (expr -> expr MINUS term .)
    COMMA           reduce using rule 21 (expr -> expr MINUS term .)
    RBRACE          reduce using rule 21 (expr -> expr MINUS term .)
    RBRACKET        reduce using rule 21 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 21 (expr -> expr MINUS term .)
    LT              reduce using rule 21 (expr -> expr MINUS term .)
    LE              reduce using rule 21 (expr -> expr MINUS term .)
    GT              reduce using rule 21 (expr -> expr MINUS term .)
    GE              reduce using rule 21 (expr -> expr MINUS term .)
    EQ              reduce using rule 21 (expr -> expr MINUS term .)
    NE              reduce using rule 21 (expr -> expr MINUS term .)
    AND             reduce using rule 21 (expr -> expr MINUS term .)
    OR              reduce using rule 21 (expr -> expr MINUS term .)
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41
    EDIVIDE         shift and go to state 42


state 58

    (13) assignment -> variable ASSIGN expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    PRINT           reduce using rule 13 (assignment -> variable ASSIGN expr .)
    IF              reduce using rule 13 (assignment -> variable ASSIGN expr .)
    WHILE           reduce using rule 13 (assignment -> variable ASSIGN expr .)
    FOR             reduce using rule 13 (assignment -> variable ASSIGN expr .)
    BREAK           reduce using rule 13 (assignment -> variable ASSIGN expr .)
    DEF             reduce using rule 13 (assignment -> variable ASSIGN expr .)
    RETURN          reduce using rule 13 (assignment -> variable ASSIGN expr .)
    ID              reduce using rule 13 (assignment -> variable ASSIGN expr .)
    LBRACKET        reduce using rule 13 (assignment -> variable ASSIGN expr .)
    NUMBER          reduce using rule 13 (assignment -> variable ASSIGN expr .)
    LPAREN          reduce using rule 13 (assignment -> variable ASSIGN expr .)
    LEN             reduce using rule 13 (assignment -> variable ASSIGN expr .)
    $end            reduce using rule 13 (assignment -> variable ASSIGN expr .)
    SEMICOLON       reduce using rule 13 (assignment -> variable ASSIGN expr .)
    RBRACE          reduce using rule 13 (assignment -> variable ASSIGN expr .)
    RPAREN          reduce using rule 13 (assignment -> variable ASSIGN expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 59

    (14) assignment -> variable MINEQUAL expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    PRINT           reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    IF              reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    WHILE           reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    FOR             reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    BREAK           reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    DEF             reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    RETURN          reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    ID              reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    LBRACKET        reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    NUMBER          reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    LPAREN          reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    LEN             reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    $end            reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    SEMICOLON       reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    RBRACE          reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    RPAREN          reduce using rule 14 (assignment -> variable MINEQUAL expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 60

    (15) assignment -> variable PLUSEQUAL expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    PRINT           reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    IF              reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    WHILE           reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    FOR             reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    BREAK           reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    DEF             reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    RETURN          reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    ID              reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    LBRACKET        reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    NUMBER          reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    LPAREN          reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    LEN             reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    $end            reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    SEMICOLON       reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    RBRACE          reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    RPAREN          reduce using rule 15 (assignment -> variable PLUSEQUAL expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 61

    (18) variable -> variable LBRACKET expr . RBRACKET
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    RBRACKET        shift and go to state 83
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 62

    (24) term -> term TIMES factor .

    TIMES           reduce using rule 24 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 24 (term -> term TIMES factor .)
    EDIVIDE         reduce using rule 24 (term -> term TIMES factor .)
    PLUS            reduce using rule 24 (term -> term TIMES factor .)
    MINUS           reduce using rule 24 (term -> term TIMES factor .)
    PRINT           reduce using rule 24 (term -> term TIMES factor .)
    IF              reduce using rule 24 (term -> term TIMES factor .)
    WHILE           reduce using rule 24 (term -> term TIMES factor .)
    FOR             reduce using rule 24 (term -> term TIMES factor .)
    BREAK           reduce using rule 24 (term -> term TIMES factor .)
    DEF             reduce using rule 24 (term -> term TIMES factor .)
    RETURN          reduce using rule 24 (term -> term TIMES factor .)
    ID              reduce using rule 24 (term -> term TIMES factor .)
    LBRACKET        reduce using rule 24 (term -> term TIMES factor .)
    NUMBER          reduce using rule 24 (term -> term TIMES factor .)
    LPAREN          reduce using rule 24 (term -> term TIMES factor .)
    LEN             reduce using rule 24 (term -> term TIMES factor .)
    $end            reduce using rule 24 (term -> term TIMES factor .)
    RPAREN          reduce using rule 24 (term -> term TIMES factor .)
    COMMA           reduce using rule 24 (term -> term TIMES factor .)
    RBRACE          reduce using rule 24 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 24 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 24 (term -> term TIMES factor .)
    LT              reduce using rule 24 (term -> term TIMES factor .)
    LE              reduce using rule 24 (term -> term TIMES factor .)
    GT              reduce using rule 24 (term -> term TIMES factor .)
    GE              reduce using rule 24 (term -> term TIMES factor .)
    EQ              reduce using rule 24 (term -> term TIMES factor .)
    NE              reduce using rule 24 (term -> term TIMES factor .)
    AND             reduce using rule 24 (term -> term TIMES factor .)
    OR              reduce using rule 24 (term -> term TIMES factor .)


state 63

    (25) term -> term DIVIDE factor .

    TIMES           reduce using rule 25 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 25 (term -> term DIVIDE factor .)
    EDIVIDE         reduce using rule 25 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 25 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 25 (term -> term DIVIDE factor .)
    PRINT           reduce using rule 25 (term -> term DIVIDE factor .)
    IF              reduce using rule 25 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 25 (term -> term DIVIDE factor .)
    FOR             reduce using rule 25 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 25 (term -> term DIVIDE factor .)
    DEF             reduce using rule 25 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 25 (term -> term DIVIDE factor .)
    ID              reduce using rule 25 (term -> term DIVIDE factor .)
    LBRACKET        reduce using rule 25 (term -> term DIVIDE factor .)
    NUMBER          reduce using rule 25 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 25 (term -> term DIVIDE factor .)
    LEN             reduce using rule 25 (term -> term DIVIDE factor .)
    $end            reduce using rule 25 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 25 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 25 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 25 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 25 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 25 (term -> term DIVIDE factor .)
    LT              reduce using rule 25 (term -> term DIVIDE factor .)
    LE              reduce using rule 25 (term -> term DIVIDE factor .)
    GT              reduce using rule 25 (term -> term DIVIDE factor .)
    GE              reduce using rule 25 (term -> term DIVIDE factor .)
    EQ              reduce using rule 25 (term -> term DIVIDE factor .)
    NE              reduce using rule 25 (term -> term DIVIDE factor .)
    AND             reduce using rule 25 (term -> term DIVIDE factor .)
    OR              reduce using rule 25 (term -> term DIVIDE factor .)


state 64

    (26) term -> term EDIVIDE factor .

    TIMES           reduce using rule 26 (term -> term EDIVIDE factor .)
    DIVIDE          reduce using rule 26 (term -> term EDIVIDE factor .)
    EDIVIDE         reduce using rule 26 (term -> term EDIVIDE factor .)
    PLUS            reduce using rule 26 (term -> term EDIVIDE factor .)
    MINUS           reduce using rule 26 (term -> term EDIVIDE factor .)
    PRINT           reduce using rule 26 (term -> term EDIVIDE factor .)
    IF              reduce using rule 26 (term -> term EDIVIDE factor .)
    WHILE           reduce using rule 26 (term -> term EDIVIDE factor .)
    FOR             reduce using rule 26 (term -> term EDIVIDE factor .)
    BREAK           reduce using rule 26 (term -> term EDIVIDE factor .)
    DEF             reduce using rule 26 (term -> term EDIVIDE factor .)
    RETURN          reduce using rule 26 (term -> term EDIVIDE factor .)
    ID              reduce using rule 26 (term -> term EDIVIDE factor .)
    LBRACKET        reduce using rule 26 (term -> term EDIVIDE factor .)
    NUMBER          reduce using rule 26 (term -> term EDIVIDE factor .)
    LPAREN          reduce using rule 26 (term -> term EDIVIDE factor .)
    LEN             reduce using rule 26 (term -> term EDIVIDE factor .)
    $end            reduce using rule 26 (term -> term EDIVIDE factor .)
    RPAREN          reduce using rule 26 (term -> term EDIVIDE factor .)
    COMMA           reduce using rule 26 (term -> term EDIVIDE factor .)
    RBRACE          reduce using rule 26 (term -> term EDIVIDE factor .)
    RBRACKET        reduce using rule 26 (term -> term EDIVIDE factor .)
    SEMICOLON       reduce using rule 26 (term -> term EDIVIDE factor .)
    LT              reduce using rule 26 (term -> term EDIVIDE factor .)
    LE              reduce using rule 26 (term -> term EDIVIDE factor .)
    GT              reduce using rule 26 (term -> term EDIVIDE factor .)
    GE              reduce using rule 26 (term -> term EDIVIDE factor .)
    EQ              reduce using rule 26 (term -> term EDIVIDE factor .)
    NE              reduce using rule 26 (term -> term EDIVIDE factor .)
    AND             reduce using rule 26 (term -> term EDIVIDE factor .)
    OR              reduce using rule 26 (term -> term EDIVIDE factor .)


state 65

    (36) print -> PRINT LPAREN exprs . RPAREN
    (33) exprs -> exprs . COMMA expr

    RPAREN          shift and go to state 84
    COMMA           shift and go to state 80


state 66

    (37) print -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    WHILE           reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    BREAK           reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    DEF             reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    ID              reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    LBRACKET        reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    NUMBER          reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    LPAREN          reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    LEN             reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 37 (print -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 37 (print -> PRINT LPAREN RPAREN .)


state 67

    (32) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    EDIVIDE         reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    PRINT           reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    IF              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    FOR             reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    BREAK           reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    DEF             reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    ID              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    NUMBER          reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    LEN             reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    $end            reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 32 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 32 (factor -> LPAREN expr RPAREN .)


state 68

    (52) if -> IF LPAREN condition . RPAREN LBRACE statements RBRACE
    (53) if -> IF LPAREN condition . RPAREN LBRACE statements RBRACE else
    (40) condition -> condition . OR join

    RPAREN          shift and go to state 85
    OR              shift and go to state 86


state 69

    (41) condition -> join .
    (42) join -> join . AND equality

    RPAREN          reduce using rule 41 (condition -> join .)
    OR              reduce using rule 41 (condition -> join .)
    SEMICOLON       reduce using rule 41 (condition -> join .)
    AND             shift and go to state 87


state 70

    (43) join -> equality .
    (44) equality -> equality . EQ rel
    (45) equality -> equality . NE rel

    AND             reduce using rule 43 (join -> equality .)
    RPAREN          reduce using rule 43 (join -> equality .)
    OR              reduce using rule 43 (join -> equality .)
    SEMICOLON       reduce using rule 43 (join -> equality .)
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 71

    (46) equality -> rel .

    EQ              reduce using rule 46 (equality -> rel .)
    NE              reduce using rule 46 (equality -> rel .)
    AND             reduce using rule 46 (equality -> rel .)
    RPAREN          reduce using rule 46 (equality -> rel .)
    OR              reduce using rule 46 (equality -> rel .)
    SEMICOLON       reduce using rule 46 (equality -> rel .)


state 72

    (47) rel -> expr . LT expr
    (48) rel -> expr . LE expr
    (49) rel -> expr . GT expr
    (50) rel -> expr . GE expr
    (51) rel -> expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    LT              shift and go to state 90
    LE              shift and go to state 91
    GT              shift and go to state 92
    GE              shift and go to state 93
    EQ              reduce using rule 51 (rel -> expr .)
    NE              reduce using rule 51 (rel -> expr .)
    AND             reduce using rule 51 (rel -> expr .)
    RPAREN          reduce using rule 51 (rel -> expr .)
    OR              reduce using rule 51 (rel -> expr .)
    SEMICOLON       reduce using rule 51 (rel -> expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 73

    (57) while -> WHILE LPAREN condition . RPAREN LBRACE statements RBRACE
    (40) condition -> condition . OR join

    RPAREN          shift and go to state 94
    OR              shift and go to state 86


state 74

    (58) for -> FOR LPAREN assignment . SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 95


state 75

    (13) assignment -> variable . ASSIGN expr
    (14) assignment -> variable . MINEQUAL expr
    (15) assignment -> variable . PLUSEQUAL expr
    (16) assignment -> variable . DPLUS
    (17) assignment -> variable . DMINUS
    (18) variable -> variable . LBRACKET expr RBRACKET

    ASSIGN          shift and go to state 34
    MINEQUAL        shift and go to state 35
    PLUSEQUAL       shift and go to state 36
    DPLUS           shift and go to state 37
    DMINUS          shift and go to state 38
    LBRACKET        shift and go to state 39


state 76

    (19) variable -> ID .

    ASSIGN          reduce using rule 19 (variable -> ID .)
    MINEQUAL        reduce using rule 19 (variable -> ID .)
    PLUSEQUAL       reduce using rule 19 (variable -> ID .)
    DPLUS           reduce using rule 19 (variable -> ID .)
    DMINUS          reduce using rule 19 (variable -> ID .)
    LBRACKET        reduce using rule 19 (variable -> ID .)
    RPAREN          reduce using rule 19 (variable -> ID .)


state 77

    (60) function -> DEF ID LPAREN . args RPAREN LBRACE statements RBRACE
    (61) function -> DEF ID LPAREN . RPAREN LBRACE statements RBRACE
    (62) args -> . args COMMA ID
    (63) args -> . ID

    RPAREN          shift and go to state 98
    ID              shift and go to state 96

    args                           shift and go to state 97

state 78

    (64) call -> ID LPAREN exprs . RPAREN
    (33) exprs -> exprs . COMMA expr

    RPAREN          shift and go to state 99
    COMMA           shift and go to state 80


state 79

    (65) call -> ID LPAREN RPAREN .

    TIMES           reduce using rule 65 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 65 (call -> ID LPAREN RPAREN .)
    EDIVIDE         reduce using rule 65 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 65 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 65 (call -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 65 (call -> ID LPAREN RPAREN .)
    IF              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 65 (call -> ID LPAREN RPAREN .)
    FOR             reduce using rule 65 (call -> ID LPAREN RPAREN .)
    BREAK           reduce using rule 65 (call -> ID LPAREN RPAREN .)
    DEF             reduce using rule 65 (call -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 65 (call -> ID LPAREN RPAREN .)
    ID              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    LBRACKET        reduce using rule 65 (call -> ID LPAREN RPAREN .)
    NUMBER          reduce using rule 65 (call -> ID LPAREN RPAREN .)
    LPAREN          reduce using rule 65 (call -> ID LPAREN RPAREN .)
    LEN             reduce using rule 65 (call -> ID LPAREN RPAREN .)
    $end            reduce using rule 65 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 65 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 65 (call -> ID LPAREN RPAREN .)
    RBRACE          reduce using rule 65 (call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 65 (call -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 65 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    LE              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    GE              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    NE              reduce using rule 65 (call -> ID LPAREN RPAREN .)
    AND             reduce using rule 65 (call -> ID LPAREN RPAREN .)
    OR              reduce using rule 65 (call -> ID LPAREN RPAREN .)


state 80

    (33) exprs -> exprs COMMA . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    expr                           shift and go to state 100
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 81

    (38) array -> LBRACKET exprs RBRACKET .

    PLUS            reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    MINUS           reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    PRINT           reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    IF              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    WHILE           reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    FOR             reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    BREAK           reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    DEF             reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    RETURN          reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    ID              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    LBRACKET        reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    NUMBER          reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    LPAREN          reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    LEN             reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    $end            reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    RPAREN          reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    COMMA           reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    RBRACE          reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    RBRACKET        reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    SEMICOLON       reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    LT              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    LE              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    GT              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    GE              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    EQ              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    NE              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    AND             reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)
    OR              reduce using rule 38 (array -> LBRACKET exprs RBRACKET .)


state 82

    (35) len -> LEN LPAREN variable . RPAREN
    (18) variable -> variable . LBRACKET expr RBRACKET

    RPAREN          shift and go to state 101
    LBRACKET        shift and go to state 39


state 83

    (18) variable -> variable LBRACKET expr RBRACKET .

    ASSIGN          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    MINEQUAL        reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    PLUSEQUAL       reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    DPLUS           reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    DMINUS          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    EDIVIDE         reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    PRINT           reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    IF              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    WHILE           reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    FOR             reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    BREAK           reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    DEF             reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    RETURN          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    ID              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    NUMBER          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    LEN             reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    $end            reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    LT              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    LE              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    GT              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    GE              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    EQ              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    NE              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    AND             reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)
    OR              reduce using rule 18 (variable -> variable LBRACKET expr RBRACKET .)


state 84

    (36) print -> PRINT LPAREN exprs RPAREN .

    PRINT           reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    IF              reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    WHILE           reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    FOR             reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    BREAK           reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    DEF             reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    RETURN          reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    ID              reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    LBRACKET        reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    NUMBER          reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    LPAREN          reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    LEN             reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    $end            reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)
    RBRACE          reduce using rule 36 (print -> PRINT LPAREN exprs RPAREN .)


state 85

    (52) if -> IF LPAREN condition RPAREN . LBRACE statements RBRACE
    (53) if -> IF LPAREN condition RPAREN . LBRACE statements RBRACE else

    LBRACE          shift and go to state 102


state 86

    (40) condition -> condition OR . join
    (42) join -> . join AND equality
    (43) join -> . equality
    (44) equality -> . equality EQ rel
    (45) equality -> . equality NE rel
    (46) equality -> . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    join                           shift and go to state 103
    equality                       shift and go to state 70
    rel                            shift and go to state 71
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 87

    (42) join -> join AND . equality
    (44) equality -> . equality EQ rel
    (45) equality -> . equality NE rel
    (46) equality -> . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    equality                       shift and go to state 104
    rel                            shift and go to state 71
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 88

    (44) equality -> equality EQ . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    rel                            shift and go to state 105
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 89

    (45) equality -> equality NE . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    rel                            shift and go to state 106
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 90

    (47) rel -> expr LT . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    expr                           shift and go to state 107
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 91

    (48) rel -> expr LE . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    expr                           shift and go to state 108
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 92

    (49) rel -> expr GT . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    expr                           shift and go to state 109
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 93

    (50) rel -> expr GE . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    expr                           shift and go to state 110
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 94

    (57) while -> WHILE LPAREN condition RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 111


state 95

    (58) for -> FOR LPAREN assignment SEMICOLON . condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (40) condition -> . condition OR join
    (41) condition -> . join
    (42) join -> . join AND equality
    (43) join -> . equality
    (44) equality -> . equality EQ rel
    (45) equality -> . equality NE rel
    (46) equality -> . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    condition                      shift and go to state 112
    join                           shift and go to state 69
    equality                       shift and go to state 70
    rel                            shift and go to state 71
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 96

    (63) args -> ID .

    RPAREN          reduce using rule 63 (args -> ID .)
    COMMA           reduce using rule 63 (args -> ID .)


state 97

    (60) function -> DEF ID LPAREN args . RPAREN LBRACE statements RBRACE
    (62) args -> args . COMMA ID

    RPAREN          shift and go to state 113
    COMMA           shift and go to state 114


state 98

    (61) function -> DEF ID LPAREN RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 115


state 99

    (64) call -> ID LPAREN exprs RPAREN .

    TIMES           reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    DIVIDE          reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    EDIVIDE         reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    PLUS            reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    MINUS           reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    PRINT           reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    IF              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    WHILE           reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    FOR             reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    BREAK           reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    DEF             reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    RETURN          reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    ID              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    LBRACKET        reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    NUMBER          reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    LPAREN          reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    LEN             reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    $end            reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    RPAREN          reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    COMMA           reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    RBRACE          reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    RBRACKET        reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    SEMICOLON       reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    LT              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    LE              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    GT              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    GE              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    EQ              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    NE              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    AND             reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)
    OR              reduce using rule 64 (call -> ID LPAREN exprs RPAREN .)


state 100

    (33) exprs -> exprs COMMA expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    COMMA           reduce using rule 33 (exprs -> exprs COMMA expr .)
    PRINT           reduce using rule 33 (exprs -> exprs COMMA expr .)
    IF              reduce using rule 33 (exprs -> exprs COMMA expr .)
    WHILE           reduce using rule 33 (exprs -> exprs COMMA expr .)
    FOR             reduce using rule 33 (exprs -> exprs COMMA expr .)
    BREAK           reduce using rule 33 (exprs -> exprs COMMA expr .)
    DEF             reduce using rule 33 (exprs -> exprs COMMA expr .)
    RETURN          reduce using rule 33 (exprs -> exprs COMMA expr .)
    ID              reduce using rule 33 (exprs -> exprs COMMA expr .)
    LBRACKET        reduce using rule 33 (exprs -> exprs COMMA expr .)
    NUMBER          reduce using rule 33 (exprs -> exprs COMMA expr .)
    LPAREN          reduce using rule 33 (exprs -> exprs COMMA expr .)
    LEN             reduce using rule 33 (exprs -> exprs COMMA expr .)
    $end            reduce using rule 33 (exprs -> exprs COMMA expr .)
    RBRACE          reduce using rule 33 (exprs -> exprs COMMA expr .)
    RBRACKET        reduce using rule 33 (exprs -> exprs COMMA expr .)
    RPAREN          reduce using rule 33 (exprs -> exprs COMMA expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 101

    (35) len -> LEN LPAREN variable RPAREN .

    TIMES           reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    DIVIDE          reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    EDIVIDE         reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    PLUS            reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    MINUS           reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    PRINT           reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    IF              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    WHILE           reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    FOR             reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    BREAK           reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    DEF             reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    RETURN          reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    ID              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    LBRACKET        reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    NUMBER          reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    LPAREN          reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    LEN             reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    $end            reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    RPAREN          reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    COMMA           reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    RBRACE          reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    RBRACKET        reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    SEMICOLON       reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    LT              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    LE              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    GT              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    GE              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    EQ              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    NE              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    AND             reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)
    OR              reduce using rule 35 (len -> LEN LPAREN variable RPAREN .)


state 102

    (52) if -> IF LPAREN condition RPAREN LBRACE . statements RBRACE
    (53) if -> IF LPAREN condition RPAREN LBRACE . statements RBRACE else
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statements                     shift and go to state 116
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 103

    (40) condition -> condition OR join .
    (42) join -> join . AND equality

    RPAREN          reduce using rule 40 (condition -> condition OR join .)
    OR              reduce using rule 40 (condition -> condition OR join .)
    SEMICOLON       reduce using rule 40 (condition -> condition OR join .)
    AND             shift and go to state 87


state 104

    (42) join -> join AND equality .
    (44) equality -> equality . EQ rel
    (45) equality -> equality . NE rel

    AND             reduce using rule 42 (join -> join AND equality .)
    RPAREN          reduce using rule 42 (join -> join AND equality .)
    OR              reduce using rule 42 (join -> join AND equality .)
    SEMICOLON       reduce using rule 42 (join -> join AND equality .)
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 105

    (44) equality -> equality EQ rel .

    EQ              reduce using rule 44 (equality -> equality EQ rel .)
    NE              reduce using rule 44 (equality -> equality EQ rel .)
    AND             reduce using rule 44 (equality -> equality EQ rel .)
    RPAREN          reduce using rule 44 (equality -> equality EQ rel .)
    OR              reduce using rule 44 (equality -> equality EQ rel .)
    SEMICOLON       reduce using rule 44 (equality -> equality EQ rel .)


state 106

    (45) equality -> equality NE rel .

    EQ              reduce using rule 45 (equality -> equality NE rel .)
    NE              reduce using rule 45 (equality -> equality NE rel .)
    AND             reduce using rule 45 (equality -> equality NE rel .)
    RPAREN          reduce using rule 45 (equality -> equality NE rel .)
    OR              reduce using rule 45 (equality -> equality NE rel .)
    SEMICOLON       reduce using rule 45 (equality -> equality NE rel .)


state 107

    (47) rel -> expr LT expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    EQ              reduce using rule 47 (rel -> expr LT expr .)
    NE              reduce using rule 47 (rel -> expr LT expr .)
    AND             reduce using rule 47 (rel -> expr LT expr .)
    RPAREN          reduce using rule 47 (rel -> expr LT expr .)
    OR              reduce using rule 47 (rel -> expr LT expr .)
    SEMICOLON       reduce using rule 47 (rel -> expr LT expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 108

    (48) rel -> expr LE expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    EQ              reduce using rule 48 (rel -> expr LE expr .)
    NE              reduce using rule 48 (rel -> expr LE expr .)
    AND             reduce using rule 48 (rel -> expr LE expr .)
    RPAREN          reduce using rule 48 (rel -> expr LE expr .)
    OR              reduce using rule 48 (rel -> expr LE expr .)
    SEMICOLON       reduce using rule 48 (rel -> expr LE expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 109

    (49) rel -> expr GT expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    EQ              reduce using rule 49 (rel -> expr GT expr .)
    NE              reduce using rule 49 (rel -> expr GT expr .)
    AND             reduce using rule 49 (rel -> expr GT expr .)
    RPAREN          reduce using rule 49 (rel -> expr GT expr .)
    OR              reduce using rule 49 (rel -> expr GT expr .)
    SEMICOLON       reduce using rule 49 (rel -> expr GT expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 110

    (50) rel -> expr GE expr .
    (20) expr -> expr . PLUS term
    (21) expr -> expr . MINUS term

    EQ              reduce using rule 50 (rel -> expr GE expr .)
    NE              reduce using rule 50 (rel -> expr GE expr .)
    AND             reduce using rule 50 (rel -> expr GE expr .)
    RPAREN          reduce using rule 50 (rel -> expr GE expr .)
    OR              reduce using rule 50 (rel -> expr GE expr .)
    SEMICOLON       reduce using rule 50 (rel -> expr GE expr .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 111

    (57) while -> WHILE LPAREN condition RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statements                     shift and go to state 117
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 112

    (58) for -> FOR LPAREN assignment SEMICOLON condition . SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (40) condition -> condition . OR join

    SEMICOLON       shift and go to state 118
    OR              shift and go to state 86


state 113

    (60) function -> DEF ID LPAREN args RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 119


state 114

    (62) args -> args COMMA . ID

    ID              shift and go to state 120


state 115

    (61) function -> DEF ID LPAREN RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statements                     shift and go to state 121
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 116

    (52) if -> IF LPAREN condition RPAREN LBRACE statements . RBRACE
    (53) if -> IF LPAREN condition RPAREN LBRACE statements . RBRACE else
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACE          shift and go to state 122
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statement                      shift and go to state 31
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 117

    (57) while -> WHILE LPAREN condition RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACE          shift and go to state 123
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statement                      shift and go to state 31
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 118

    (58) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON . assignment RPAREN LBRACE statements RBRACE
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID

    ID              shift and go to state 76

    assignment                     shift and go to state 124
    variable                       shift and go to state 75

state 119

    (60) function -> DEF ID LPAREN args RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statements                     shift and go to state 125
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 120

    (62) args -> args COMMA ID .

    RPAREN          reduce using rule 62 (args -> args COMMA ID .)
    COMMA           reduce using rule 62 (args -> args COMMA ID .)


state 121

    (61) function -> DEF ID LPAREN RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACE          shift and go to state 126
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statement                      shift and go to state 31
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 122

    (52) if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .
    (53) if -> IF LPAREN condition RPAREN LBRACE statements RBRACE . else
    (54) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE
    (55) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE else
    (56) else -> . ELSE LBRACE statements RBRACE

    PRINT           reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 52 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ELIF            shift and go to state 128
    ELSE            shift and go to state 129

    else                           shift and go to state 127

state 123

    (57) while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 57 (while -> WHILE LPAREN condition RPAREN LBRACE statements RBRACE .)


state 124

    (58) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 130


state 125

    (60) function -> DEF ID LPAREN args RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACE          shift and go to state 131
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statement                      shift and go to state 31
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 126

    (61) function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 61 (function -> DEF ID LPAREN RPAREN LBRACE statements RBRACE .)


state 127

    (53) if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .

    PRINT           reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    IF              reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    WHILE           reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    FOR             reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    BREAK           reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    DEF             reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RETURN          reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    ID              reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LBRACKET        reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    NUMBER          reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LPAREN          reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LEN             reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    $end            reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RBRACE          reduce using rule 53 (if -> IF LPAREN condition RPAREN LBRACE statements RBRACE else .)


state 128

    (54) else -> ELIF . LPAREN condition RPAREN LBRACE statements RBRACE
    (55) else -> ELIF . LPAREN condition RPAREN LBRACE statements RBRACE else

    LPAREN          shift and go to state 132


state 129

    (56) else -> ELSE . LBRACE statements RBRACE

    LBRACE          shift and go to state 133


state 130

    (58) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 134


state 131

    (60) function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 60 (function -> DEF ID LPAREN args RPAREN LBRACE statements RBRACE .)


state 132

    (54) else -> ELIF LPAREN . condition RPAREN LBRACE statements RBRACE
    (55) else -> ELIF LPAREN . condition RPAREN LBRACE statements RBRACE else
    (40) condition -> . condition OR join
    (41) condition -> . join
    (42) join -> . join AND equality
    (43) join -> . equality
    (44) equality -> . equality EQ rel
    (45) equality -> . equality NE rel
    (46) equality -> . rel
    (47) rel -> . expr LT expr
    (48) rel -> . expr LE expr
    (49) rel -> . expr GT expr
    (50) rel -> . expr GE expr
    (51) rel -> . expr
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    ID              shift and go to state 23
    LEN             shift and go to state 30

    condition                      shift and go to state 135
    join                           shift and go to state 69
    equality                       shift and go to state 70
    rel                            shift and go to state 71
    expr                           shift and go to state 72
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    variable                       shift and go to state 45
    len                            shift and go to state 28
    call                           shift and go to state 29

state 133

    (56) else -> ELSE LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statements                     shift and go to state 136
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 134

    (58) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    assignment                     shift and go to state 4
    statements                     shift and go to state 137
    statement                      shift and go to state 3
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 135

    (54) else -> ELIF LPAREN condition . RPAREN LBRACE statements RBRACE
    (55) else -> ELIF LPAREN condition . RPAREN LBRACE statements RBRACE else
    (40) condition -> condition . OR join

    RPAREN          shift and go to state 138
    OR              shift and go to state 86


state 136

    (56) else -> ELSE LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACE          shift and go to state 139
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statement                      shift and go to state 31
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 137

    (58) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACE          shift and go to state 140
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    assignment                     shift and go to state 4
    statement                      shift and go to state 31
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 138

    (54) else -> ELIF LPAREN condition RPAREN . LBRACE statements RBRACE
    (55) else -> ELIF LPAREN condition RPAREN . LBRACE statements RBRACE else

    LBRACE          shift and go to state 141


state 139

    (56) else -> ELSE LBRACE statements RBRACE .

    PRINT           reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    IF              reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    WHILE           reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    FOR             reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    BREAK           reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    DEF             reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    RETURN          reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    ID              reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    NUMBER          reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    LPAREN          reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    LEN             reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    $end            reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)
    RBRACE          reduce using rule 56 (else -> ELSE LBRACE statements RBRACE .)


state 140

    (58) for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .

    PRINT           reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 58 (for -> FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE .)


state 141

    (54) else -> ELIF LPAREN condition RPAREN LBRACE . statements RBRACE
    (55) else -> ELIF LPAREN condition RPAREN LBRACE . statements RBRACE else
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statements                     shift and go to state 142
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 142

    (54) else -> ELIF LPAREN condition RPAREN LBRACE statements . RBRACE
    (55) else -> ELIF LPAREN condition RPAREN LBRACE statements . RBRACE else
    (2) statements -> statements . statement
    (4) statement -> . assignment
    (5) statement -> . expr
    (6) statement -> . print
    (7) statement -> . if
    (8) statement -> . while
    (9) statement -> . for
    (10) statement -> . break
    (11) statement -> . function
    (12) statement -> . return
    (13) assignment -> . variable ASSIGN expr
    (14) assignment -> . variable MINEQUAL expr
    (15) assignment -> . variable PLUSEQUAL expr
    (16) assignment -> . variable DPLUS
    (17) assignment -> . variable DMINUS
    (20) expr -> . expr PLUS term
    (21) expr -> . expr MINUS term
    (22) expr -> . term
    (23) expr -> . array
    (36) print -> . PRINT LPAREN exprs RPAREN
    (37) print -> . PRINT LPAREN RPAREN
    (52) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE
    (53) if -> . IF LPAREN condition RPAREN LBRACE statements RBRACE else
    (57) while -> . WHILE LPAREN condition RPAREN LBRACE statements RBRACE
    (58) for -> . FOR LPAREN assignment SEMICOLON condition SEMICOLON assignment RPAREN LBRACE statements RBRACE
    (59) break -> . BREAK
    (60) function -> . DEF ID LPAREN args RPAREN LBRACE statements RBRACE
    (61) function -> . DEF ID LPAREN RPAREN LBRACE statements RBRACE
    (66) return -> . RETURN
    (67) return -> . RETURN exprs
    (18) variable -> . variable LBRACKET expr RBRACKET
    (19) variable -> . ID
    (24) term -> . term TIMES factor
    (25) term -> . term DIVIDE factor
    (26) term -> . term EDIVIDE factor
    (27) term -> . factor
    (38) array -> . LBRACKET exprs RBRACKET
    (39) array -> . LBRACKET RBRACKET
    (28) factor -> . variable
    (29) factor -> . NUMBER
    (30) factor -> . len
    (31) factor -> . call
    (32) factor -> . LPAREN expr RPAREN
    (35) len -> . LEN LPAREN variable RPAREN
    (64) call -> . ID LPAREN exprs RPAREN
    (65) call -> . ID LPAREN RPAREN

    RBRACE          shift and go to state 143
    PRINT           shift and go to state 16
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    BREAK           shift and go to state 21
    DEF             shift and go to state 22
    RETURN          shift and go to state 24
    ID              shift and go to state 23
    LBRACKET        shift and go to state 25
    NUMBER          shift and go to state 27
    LPAREN          shift and go to state 17
    LEN             shift and go to state 30

    statement                      shift and go to state 31
    assignment                     shift and go to state 4
    expr                           shift and go to state 5
    print                          shift and go to state 6
    if                             shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9
    break                          shift and go to state 10
    function                       shift and go to state 11
    return                         shift and go to state 12
    variable                       shift and go to state 13
    term                           shift and go to state 14
    array                          shift and go to state 15
    factor                         shift and go to state 26
    len                            shift and go to state 28
    call                           shift and go to state 29

state 143

    (54) else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .
    (55) else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE . else
    (54) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE
    (55) else -> . ELIF LPAREN condition RPAREN LBRACE statements RBRACE else
    (56) else -> . ELSE LBRACE statements RBRACE

    PRINT           reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    WHILE           reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    BREAK           reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    DEF             reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RETURN          reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ID              reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LBRACKET        reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    NUMBER          reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LPAREN          reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    LEN             reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 54 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE .)
    ELIF            shift and go to state 128
    ELSE            shift and go to state 129

    else                           shift and go to state 144

state 144

    (55) else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .

    PRINT           reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    IF              reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    WHILE           reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    FOR             reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    BREAK           reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    DEF             reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RETURN          reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    ID              reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LBRACKET        reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    NUMBER          reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LPAREN          reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    LEN             reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    $end            reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)
    RBRACE          reduce using rule 55 (else -> ELIF LPAREN condition RPAREN LBRACE statements RBRACE else .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 13 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 23 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 24 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 24 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 24 resolved as shift
WARNING: shift/reduce conflict for ID in state 24 resolved as shift
WARNING: shift/reduce conflict for LEN in state 24 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 45 resolved as shift
