# 哲学家进餐问题

假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌上有五碗意大利面，每位哲学家之间各有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子。

## 基础想法

```c++
semaphore chopstick[5] = {1, 1, 1, 1, 1};
Pi(){
    do{
        think()
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
        eat();
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        thick();
    }while(1);
}
```

若五位哲学家同时饥饿而各自拿起了左边的筷子，这使五个信号量 chopstick 均为 0，当他们试图去拿起右边的筷子时，都将因无筷子而无限期地等待下去，即可能会引起死锁。



## 方式1

至多只允许四位哲学家同时去拿左筷子，最终能保证至少有一位哲学家能进餐，并在用完后释放两只筷子供他人使用

```C++
semaphore chopstick[5] = {1, 1, 1, 1, 1};
semaphore count = 4;
Pi(){
    do{
    	think();
    	P(count)
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
        eat();
    	V(count)
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        thick();
    }while(1);
}
```



## 方式2

仅当哲学家的左右手筷子都拿起时才允许进餐。

### 解法1:

通过互斥信号量 mutex 对 eat() 之前取左侧和右侧筷子的操作进行保护，可以防止死锁的出现。

```C++
semaphore chopstick[5] = {1, 1, 1, 1, 1};
semaphore mutex = 1;
Pi(){
    do{
    	think();
    	P(mutex)
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
        eat();
    	P(mutex)
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        thick();
    }while(1);
}
```

### 解法2:

利用 AND 型信号量机制实现

```C++
```



## 方式3

