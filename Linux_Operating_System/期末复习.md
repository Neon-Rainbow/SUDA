[toc]



# Linux

# 常用命令集合

## 系统信息

```
arch 显示机器的处理器架构(1)
uname -m 显示机器的处理器架构(2)
uname -r 显示正在使用的内核版本
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)
hdparm -i /dev/hda 罗列一个磁盘的架构特性
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作
cat /proc/cpuinfo 显示CPU info的信息
cat /proc/interrupts 显示中断
cat /proc/meminfo 校验内存使用
cat /proc/swaps 显示哪些swap被使用
cat /proc/version 显示内核的版本
cat /proc/net/dev 显示网络适配器及统计
cat /proc/mounts 显示已加载的文件系统
lspci -tv 罗列 PCI 设备
lsusb -tv 显示 USB 设备
date 显示系统日期
cal 2007 显示2007年的日历表
date 041217002007.00 设置日期和时间 - 月日时分年.秒
clock -w 将时间修改保存到 BIOS
```

## 关机 (系统的关机、重启以及登出 )

```
shutdown -h now 关闭系统(1)
init 0 关闭系统(2)
telinit 0 关闭系统(3)
shutdown -h hours:minutes & 按预定时间关闭系统
shutdown -c 取消按预定时间关闭系统
shutdown -r now 重启(1)
reboot 重启(2)
logout 注销
```

## 文件和目录

```
cd /home 进入 '/ home' 目录'
cd .. 返回上一级目录
cd ../.. 返回上两级目录
cd 进入个人的主目录
cd ~user1 进入个人的主目录
cd - 返回上次所在的目录
pwd 显示工作路径
ls 查看目录中的文件
ls -F 查看目录中的文件
ls -l 显示文件和目录的详细资料
ls -a 显示隐藏文件
ls *[0-9]* 显示包含数字的文件名和目录名
tree 显示文件和目录由根目录开始的树形结构(1)
lstree 显示文件和目录由根目录开始的树形结构(2)
mkdir dir1 创建一个叫做 'dir1' 的目录'
mkdir dir1 dir2 同时创建两个目录
mkdir -p /tmp/dir1/dir2 创建一个目录树
rm -f file1 删除一个叫做 'file1' 的文件'
rmdir dir1 删除一个叫做 'dir1' 的目录'
rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容
rm -rf dir1 dir2 同时删除两个目录及它们的内容
mv dir1 new_dir 重命名/移动 一个目录
cp file1 file2 复制一个文件
cp dir/* . 复制一个目录下的所有文件到当前工作目录
cp -a /tmp/dir1 . 复制一个目录到当前工作目录
cp -a dir1 dir2 复制一个目录
ln -s file1 lnk1 创建一个指向文件或目录的软链接
ln file1 lnk1 创建一个指向文件或目录的物理链接
touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)
file file1 outputs the mime type of the file as text
iconv -l 列出已知的编码
iconv -f fromEncoding -t toEncoding inputFile > outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.
find . -maxdepth 1 -name *.jpg -print -exec convert "{}" -resize 80x60 "thumbs/{}" \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)
```

## 文件搜索

```
find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录
find / -user user1 搜索属于用户 'user1' 的文件和目录
find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件
find / -name \*.rpm -exec chmod 755 '{}' \; 搜索以 '.rpm' 结尾的文件并定义其权限
find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备
locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令
whereis halt 显示一个二进制文件、源码或man的位置
which halt 显示一个二进制文件或可执行文件的完整路径
```

## 挂载一个文件系统

```
mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在
umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出
fuser -km /mnt/hda2 当设备繁忙时强制卸载
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用
mount /dev/fd0 /mnt/floppy 挂载一个软盘
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享
```

## 磁盘空间

```
df -h 显示已经挂载的分区列表
ls -lSr |more 以尺寸大小排列文件和目录
du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'
du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小
rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)
dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)
```

## 用户和群组

```
groupadd group_name 创建一个新用户组
groupdel group_name 删除一个用户组
groupmod -n new_group_name old_group_name 重命名一个用户组
useradd -c "Name Surname " -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 "admin" 用户组的用户
useradd user1 创建一个新用户
userdel -r user1 删除一个用户 ( '-r' 排除主目录)
usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性
passwd 修改口令
passwd user1 修改一个用户的口令 (只允许root执行)
chage -E 2005-12-31 user1 设置用户口令的失效期限
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组
```

## 文件的权限 - 使用 "+" 设置权限，使用 "-" 用于取消

```
ls -lh 显示权限
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限
chown user1 file1 改变一个文件的所有人属性
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性
chgrp group1 file1 改变文件的群组
chown user1:group1 file1 改变一个文件的所有人和群组属性
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的
chmod g-s /home/public 禁用一个目录的 SGID 位
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件
chmod o-t /home/public 禁用一个目录的 STIKY 位
```

## 文件的特殊属性 - 使用 "+" 设置权限，使用 "-" 用于取消

```
chattr +a file1 只允许以追加方式读写文件
chattr +c file1 允许这个文件能被内核自动压缩/解压
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接
chattr +s file1 允许一个文件被安全地删除
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件
lsattr 显示特殊的属性
```

## 打包和压缩文件

```
bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件
bzip2 file1 压缩一个叫做 'file1' 的文件
gunzip file1.gz 解压一个叫做 'file1.gz'的文件
gzip file1 压缩一个叫做 'file1'的文件
gzip -9 file1 最大程度压缩
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1'
rar x file1.rar 解压rar包
unrar x file1.rar 解压rar包
tar -cvf archive.tar file1 创建一个非压缩的 tarball
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件
tar -tf archive.tar 显示一个包中的内容
tar -xvf archive.tar 释放一个包
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包
tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包
tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包
zip file1.zip file1 创建一个zip格式的压缩包
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包
unzip file1.zip 解压一个zip格式压缩包
```

## RPM 包 - （Fedora, Redhat及类似系统）

```
rpm -ivh package.rpm 安装一个rpm包
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告
rpm -U package.rpm 更新一个rpm包但不改变其配置文件
rpm -F package.rpm 更新一个确定已经安装的rpm包
rpm -e package_name.rpm 删除一个rpm包
rpm -qa 显示系统中所有已经安装的rpm包
rpm -qa | grep httpd 显示所有名称中包含 "httpd" 字样的rpm包
rpm -qi package_name 获取一个已安装包的特殊信息
rpm -qg "System Environment/Daemons" 显示一个组件的rpm包
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表
rpm -q package_name --whatprovides 显示一个rpm包所占的体积
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l
rpm -q package_name --changelog 显示一个rpm包的修改历史
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书
rpm --checksig package.rpm 确认一个rpm包的完整性
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间
rpm -Va 检查系统中所有已安装的rpm包- 小心使用
rpm -Vp package.rpm 确认一个rpm包还未安装
rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件
rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包
```

## YUM 软件包升级器 - （Fedora, RedHat及类似系统）

```
yum install package_name 下载并安装一个rpm包
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系
yum update package_name.rpm 更新当前系统中所有安装的rpm包
yum update package_name 更新一个rpm包
yum remove package_name 删除一个rpm包
yum list 列出当前系统中安装的所有包
yum search package_name 在rpm仓库中搜寻软件包
yum clean packages 清理rpm缓存删除下载的包
yum clean headers 删除所有头文件
yum clean all 删除所有缓存的包和头文件
```

## DEB 包 (Debian, Ubuntu 以及类似系统)

```
dpkg -i package.deb 安装/更新一个 deb 包
dpkg -r package_name 从系统删除一个 deb 包
dpkg -l 显示系统中所有已经安装的 deb 包
dpkg -l | grep httpd 显示所有名称中包含 "httpd" 字样的deb包
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供
```

## APT 软件工具 (Debian, Ubuntu 以及类似系统)

```
apt-get install package_name 安装/更新一个 deb 包
apt-cdrom install package_name 从光盘安装/更新一个 deb 包
apt-get update 升级列表中的软件包
apt-get upgrade 升级所有已安装的软件
apt-get remove package_name 从系统删除一个deb包
apt-get check 确认依赖的软件仓库正确
apt-get clean 从下载的软件包中清理缓存
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称
```

## 查看文件内容

```
cat file1 从第一个字节开始正向查看文件的内容
tac file1 从最后一行开始反向查看一个文件的内容
more file1 查看一个长文件的内容
less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作
head -2 file1 查看一个文件的前两行
tail -2 file1 查看一个文件的最后两行
tail -f /var/log/messages 实时查看被添加到一个文件中的内容
```

## 文本处理

```
cat file1 file2 ... | command <> file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT
cat file1 | command( sed, grep, awk, grep, etc...) > result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中
cat file1 | command( sed, grep, awk, grep, etc...) >> result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中
grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词"Aug"
grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以"Aug"开始的词汇
grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行
grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串"Aug"
sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 "string1" 替换成 "string2"
sed '/^$/d' example.txt 从example.txt文件中删除所有空白行
sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行
echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容
sed -e '1d' result.txt 从文件example.txt 中排除第一行
sed -n '/stringa1/p' 查看只包含词汇 "string1"的行
sed -e 's/ *$//' example.txt 删除每一行最后的空白字符
sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 "string1" 并保留剩余全部
sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容
sed -n '5p;5q' example.txt 查看第5行
sed -e 's/00*/0/g' example.txt 用单个零替换多个零
cat -n file1 标示文件的行数
cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行
echo a b c | awk '{print $1}' 查看一行第一栏
echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏
paste file1 file2 合并两个文件或两栏的内容
paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用"+"区分
sort file1 file2 排序两个文件的内容
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)
sort file1 file2 | uniq -u 删除交集，留下其他的行
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)
comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容
comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分
```

## 字符设置和文件格式转换

```
dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS
recode ..HTML < page.txt > page.html 将一个文本文件转换成html
recode -l | more 显示所有允许的转换格式
```

## 文件系统分析

```
badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性
```

## 初始化一个文件系统

```
mkfs /dev/hda1 在hda1分区创建一个文件系统
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统
fdformat -n /dev/fd0 格式化一个软盘
mkswap /dev/hda3 创建一个swap文件系统
```

## SWAP文件系统

```
mkswap /dev/hda3 创建一个swap文件系统
swapon /dev/hda3 启用一个新的swap文件系统
swapon /dev/hda2 /dev/hdb3 启用两个swap分区
```

## 备份

```
dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份
restore -if /tmp/home0.bak 还原一个交互式备份
rsync -rogpav --delete /home /tmp 同步两边的目录
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件
tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作
( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p' 通过ssh在远程目录中复制一个目录内容
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p' 通过ssh在远程目录中复制一个本地目录
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容
```

## 光盘

```
cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容
mkisofs /dev/cdrom > cd.iso 在磁盘上创建一个光盘的iso镜像文件
mkisofs /dev/cdrom | gzip > cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件
mkisofs -J -allow-leading-dots -R -V "Label CD" -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中
cd-paranoia -- "-3" 从一个CD光盘转录音轨到 wav 文件中（参数-3）
cdrecord --scanbus 扫描总线以识别scsi通道
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD
```

## 网络 - （以太网和WIFI无线）

```
ifconfig eth0 显示一个以太网卡的配置
ifup eth0 启用一个 'eth0' 网络设备
ifdown eth0 禁用一个 'eth0' 网络设备
ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址
ifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing)
dhclient eth0 以dhcp模式启用 'eth0'
route -n show routing table
route add -net 0/0 gw IP_Gateway configura default gateway
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16'
route del 0/0 gw IP_gateway remove static route
echo "1" > /proc/sys/net/ipv4/ip_forward activate ip routing
hostname show hostname of system
host www.example.com lookup hostname to resolve name to ip address and viceversa(1)
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)
ip link show show link status of all interfaces
mii-tool eth0 show link status of 'eth0'
ethtool eth0 show statistics of network card 'eth0'
netstat -tup show all active network connections and their PID
netstat -tupl show all network services listening on the system and their PID
tcpdump tcp port 80 show all HTTP traffic
iwlist scan show wireless networks
iwconfig eth1 show configuration of a wireless network card
hostname show hostname
host www.example.com lookup hostname to resolve name to ip address and viceversa
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa
whois www.example.com lookup on Whois database
```



# 实验1

快捷键

ctrl+c：结束终止当前命令

Tab：自动补全

ctrl+d / exit：退出当前终端

ctrl+l：清屏

ctrl+a：光标移动到命令最前面

ctrl+e：光标移动到命令最后面



关机和重启:

```bash
shutdown [-t seconds] [-rkhncfF] time [message]
```

**参数说明**：

- -t seconds : 设定在几秒钟之后进行关机程序。
- -k : 并不会真的关机，只是将警告讯息传送给所有使用者。
- -r : 关机后重新开机。
- -h : 关机后停机。
- -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。
- -c : 取消目前已经进行中的关机动作。
- -f : 关机时，不做 fsck 动作(检查 Linux 档系统)。
- -F : 关机时，强迫进行 fsck 动作。
- time : 设定关机的时间。
- message : 传送给所有使用者的警告讯息。

立即关机

```
# shutdown -h now
```

指定 10 分钟后关机

```
# shutdown -h 10
```

重新启动计算机

```
# shutdown -r now
```

# 实验2

## mv

```
mv [options] source dest
mv [options] source... directory
```

**参数说明**：

- **-b**: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。
- **-i**: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。
- **-f**: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。
- **-n**: 不要覆盖任何已存在的文件或目录。
- **-u**：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。

mv 参数设置与运行结果

| 命令格式                                         | 运行结果                                                     |
| :----------------------------------------------- | :----------------------------------------------------------- |
| `mv source_file(文件) dest_file(文件)`           | 将源文件名 source_file 改为目标文件名 dest_file              |
| `mv source_file(文件) dest_directory(目录)`      | 将文件 source_file 移动到目标目录 dest_directory 中          |
| `mv source_directory(目录) dest_directory(目录)` | 目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory |
| `mv source_directory(目录) dest_file(文件)`      | 出错                                                         |

将文件 aaa 改名为 bbb :

```
mv aaa bbb
```

将 info 目录放入 logs 目录中。注意，如果 logs 目录不存在，则该命令将 info 改名为 logs。

```
mv info/ logs 
```

再如将 **/usr/runoob** 下的所有文件和目录移到当前目录下，命令行为：

```
$ mv /usr/runoob/*  . 
```



**mv 操作文件时是移动并且重命名。**

目标目录与原目录一致，指定了新文件名，效果就是仅仅重命名。

```
mv  /home/ffxhd/a.txt   /home/ffxhd/b.txt    
```

目标目录与原目录不一致，没有指定新文件名，效果就是仅仅移动。

```
mv  /home/ffxhd/a.txt   /home/ffxhd/test/ 
或者
mv  /home/ffxhd/a.txt   /home/ffxhd/test 
```

目标目录与原目录一致, 指定了新文件名，效果就是：移动 + 重命名。

```
mv  /home/ffxhd/a.txt   /home/ffxhd/test/c.txt
```

\------------------------------------------------------

批量移动文件和文件夹：(在Ubuntu 18.04 奏效）

例如，将 **/home/ffxhd/testThinkPHP5/tp5** 目录里边的所有文件&文件夹 挪到 **/home/ffxhd/testThinkPHP5**

```
mv  /home/ffxhd/testThinkPHP5/tp5/*  /home/ffxhd/testThinkPHP5
```

注意：需要先执行显示隐藏文件命令，否则，隐藏文件以及隐藏文件夹不会被移动到新目录。

英语点号开头的文件会被作为隐藏文件处理，英语点号开头的文件夹也被作为隐藏文件夹处理。

例如：文件 **.a.txt**， 目录 **.tp5**。

## cd

Linux cd（英文全拼：change directory）命令用于改变当前工作目录的命令，切换到指定的路径。

若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。

另外，**~** 也表示为 home 目录 的意思， **.** 则是表示目前所在的目录， **..** 则表示目前目录位置的上一层目录。



```
cd [dirName]
```

- dirName：要切换的目标目录，可以是相对路径或绝对路径。

**换到绝对路径：**指定完整的目录路径来切换到目标目录。

```
cd /path/to/directory
```

**切换到相对路径：**指定相对于当前目录的路径来切换到目标目录。

```
cd relative/path/to/directory
```



切换到 /usr/bin/ 目录:

```
cd /usr/bin
```

**切换到上级目录：**使用 **..** 表示上级目录，可以通过连续多次使用 **..** 来切换到更高级的目录。

```
cd ..
cd ../../   // 切换到上上级目录
```

**切换到用户主目录（home）：**使用 **~** 表示当前用户的主目录，可以使用 cd 命令直接切换到主目录。

```
cd ~
```

**切换到上次访问的目录：**使用 **cd -** 可以切换到上次访问的目录。

```
cd -
```

**切换到环境变量指定的目录：**可以使用环境变量来指定目标目录，并使用 **cd** 命令切换到该目录。

```
cd $VAR_NAME
```

以上实例都是 cd 命令的一些基本用法，它们可以帮助您在 Linux 系统中进行目录切换操作。

使用 **cd --help** 命令可以获取更多关于 cd 命令的详细信息，包括可用的选项和更高级的用法。

## pwd

Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。

执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。



```
pwd [--help][--version]
```

**参数说明:**

- --help 在线帮助。
- --version 显示版本信息。



查看当前所在目录：

```
# pwd
/root/test           #输出结果
```



## 自己设计一个小实验，用到 cd、pwd、cd .. 命令

实验目标：

1. 从你的主目录开始。
2. 创建一个新目录结构。
3. 在这个目录结构中导航。
4. 使用 `pwd` 命令来验证当前目录。
5. 使用 `cd ..` 来回到上一级目录。

步骤：

1. 打开你的终端或命令行界面。
2. 使用 `pwd` 命令查看你的当前工作目录。这应该是你的主目录。
3. 使用 `mkdir` 命令创建一个新目录。例如：`mkdir experiment`。
4. 进入这个新目录：`cd experiment`。
5. 在这个新目录中，再创建两个子目录，例如：`mkdir subdir1 subdir2`。
6. 进入其中一个子目录：`cd subdir1`。
7. 使用 `pwd` 命令确认你现在在 `subdir1`。
8. 然后使用 `cd ..` 返回上一级目录（即 `experiment` 目录）。
9. 再次使用 `pwd` 验证你现在在 `experiment` 目录。
10. 最后，你可以用 `cd` 命令回到主目录或继续探索文件系统。
## rm

Linux rm（英文全拼：remove）命令用于删除一个文件或者目录。



```
rm [options] name...
```

**参数**：

- -i 删除前逐一询问确认。
- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
- -r 将目录及以下之档案亦逐一删除。



删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"，例如：

```
# rm  test.txt 
rm：是否删除 一般文件 "test.txt"? y  
# rm  homework  
rm: 无法删除目录"homework": 是一个目录  
# rm  -r  homework  
rm：是否删除 目录 "homework"? y 
```

删除当前目录下的所有文件及目录，命令行为：

```
rm  -r  * 
```

文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。

## cp

Linux cp（英文全拼：copy file）命令主要用于复制文件或目录。



```
cp [options] source dest
或
cp [选项] 源文件 目标文件
```

其中，source（源文件）表示要复制的文件或目录的路径，dest（目标文件）表示复制后的文件或目录的路径。

或

```
cp [options] source... directory
```

**选项说明**：

- -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。
- -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。
- `-r` 或 `--recursive`：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。
- `-i` 或 `--interactive`：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 **y** 时目标文件将被覆盖。。
- `-u` 或 `--update`：仅复制源文件中更新时间较新的文件。
- `-v` 或 `--verbose`：显示详细的复制过程。
- `-p` 或 `--preserve`：保留源文件的权限、所有者和时间戳信息。
- `-f` 或 `--force`：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。
- -l：不复制文件，只是生成链接文件。



将文件 file.txt 复制到目录 /path/to/destination/ 中：

```
cp file.txt /path/to/destination/
```

使用指令 **cp** 将当前目录 **test/** 下的所有文件复制到新目录 **newtest** 下，输入如下命令：

```
cp –r test/ newtest          
```

注意：用户使用该指令复制目录时，必须使用参数 **-r** 或者 **-R** 。

复制文件，并在目标文件已存在时进行确认：

```
cp -i file.txt /path/to/destination/
```

## cat

cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。

### 使用权限

所有使用者

### 语法格式

```
cat [-AbeEnstTuv] [--help] [--version] fileName
```

### 参数说明：

**-n 或 --number**：由 1 开始对所有输出的行数编号。

**-b 或 --number-nonblank**：和 -n 相似，只不过对于空白行不编号。

**-s 或 --squeeze-blank**：当遇到有连续两行以上的空白行，就代换为一行的空白行。

**-v 或 --show-nonprinting**：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。

**-E 或 --show-ends** : 在每行结束处显示 $。

**-T 或 --show-tabs**: 将 TAB 字符显示为 ^I。

**-A, --show-all**：等价于 -vET。

**-e：**等价于"-vE"选项；

**-t：**等价于"-vT"选项；



把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：

```
cat -n textfile1 > textfile2
```

把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：

```
cat -b textfile1 textfile2 >> textfile3
```

清空 /etc/test.txt 文档内容：

```
cat /dev/null > /etc/test.txt
```

cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：

```
cat /dev/fd0 > OUTFILE
```

相反的，如果想把 image file 写到软盘，输入：

```bash
cat IMG_FILE > /dev/fd0
```

**注**：

- 1. OUTFILE 指输出的镜像文件名。
- 2. IMG_FILE 指镜像文件。
- 3. 若从镜像文件写回 device 时，device 容量需与相当。
- 4. 通常用制作开机磁片。

## more

Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。

### 语法

```
more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]
```

**参数**：

- -num 一次显示的行数
- -d 提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声
- -l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能
- -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）
- -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容
- -c 跟 -p 相似，不同的是先显示内容再清除其他旧资料
- -s 当遇到有连续两行以上的空白行，就代换为一行的空白行
- -u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）
- +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示
- +num 从第 num 行开始显示
- fileNames 欲显示内容的文档，可为复数个数

### 实例

逐页显示 testfile 文档内容，如有连续两行以上空白行则以一行空白行显示。

```
more -s testfile
```

从第 20 行开始显示 testfile 之文档内容。

```
more +20 testfile
```

### 常用操作命令

- Enter 向下n行，需要定义。默认为1行
- Ctrl+F 向下滚动一屏
- 空格键 向下滚动一屏
- Ctrl+B 返回上一屏
- = 输出当前行的行号
- ：f 输出文件名和当前行的行号
- V 调用vi编辑器
- !命令 调用Shell，并执行命令
- q 退出more

## less

less 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。

### 语法

```
less [参数] 文件 
```

**参数说明**：

- -b <缓冲区大小> 设置缓冲区的大小
- -e 当文件显示结束后，自动离开
- -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
- -g 只标志最后搜索的关键词
- -i 忽略搜索时的大小写
- -m 显示类似more命令的百分比
- -N 显示每行的行号
- -o <文件名> 将less 输出的内容在指定文件中保存起来
- -Q 不使用警告音
- -s 显示连续空行为一行
- -S 行过长时间将超出部分舍弃
- -x <数字> 将"tab"键显示为规定的数字空格
- /字符串：向下搜索"字符串"的功能
- ?字符串：向上搜索"字符串"的功能
- n：重复前一个搜索（与 / 或 ? 有关）
- N：反向重复前一个搜索（与 / 或 ? 有关）
- b 向上翻一页
- d 向后翻半页
- h 显示帮助界面
- Q 退出less 命令
- u 向前滚动半页
- y 向前滚动一行
- 空格键 滚动一页
- 回车键 滚动一行
- [pagedown]： 向下翻动一页
- [pageup]： 向上翻动一页

### 实例

1、查看文件

```
less log2013.log
```

2、ps查看进程信息并通过less分页显示

```
ps -ef |less
```

3、查看命令历史使用记录并通过less分页显示

```
[root@localhost test]# history | less
22  scp -r tomcat6.0.32 root@192.168.120.203:/opt/soft
23  cd ..
24  scp -r web root@192.168.120.203:/opt/
25  cd soft
26  ls
……省略……
```

4、浏览多个文件

```
less log2013.log log2014.log
```

说明：
输入 ：n后，切换到 log2014.log
输入 ：p 后，切换到log2013.log

### 附加备注

1.全屏导航

- ctrl + F - 向前移动一屏
- ctrl + B - 向后移动一屏
- ctrl + D - 向前移动半屏
- ctrl + U - 向后移动半屏

2.单行导航

- j - 下一行
- k - 上一行

3.其它导航

- G - 移动到最后一行
- g - 移动到第一行
- q / ZZ - 退出 less 命令

4.其它有用的命令

- v - 使用配置的编辑器编辑当前文件
- h - 显示 less 的帮助文档
- &pattern - 仅显示匹配模式的行，而不是整个文件

5.标记导航

当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：

- ma - 使用 a 标记文本的当前位置
- 'a - 导航到标记 a 处

## head

head 命令可用于查看文件的开头部分的内容，有一个常用的参数 **-n** 用于显示行数，默认为 10，即显示 10 行的内容。

**命令格式：**

```
head [参数] [文件]  
```

**参数：**

- -q 隐藏文件名
- -v 显示文件名
- -c<数目> 显示的字节数。
- -n<行数> 显示的行数。

**实例**

要显示 runoob_notes.log 文件的开头 10 行，请输入以下命令(默认带参赛 **-n 10**)：

```
head runoob_notes.log
```

以上命令等价于：

```
head -n 10 runoon_notes.log
```

显示 notes.log 文件的开头 5 行，请输入以下命令：

```
head -n 5 runoob_notes.log
```

显示文件前 20 个字节:

```
head -c 20 runoob_notes.log
```

## tail

tail 命令可用于查看文件的内容，有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。

**tail -f filename** 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。

**命令格式：**

```
tail [参数] [文件]  
```

**参数：**

- -f 循环读取
- -q 不显示处理信息
- -v 显示详细的处理信息
- -c<数目> 显示的字节数
- -n<行数> 显示文件的尾部 n 行内容
- --pid=PID 与-f合用,表示在进程ID,PID死掉之后结束
- -q, --quiet, --silent 从不输出给出文件名的首部
- -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒

**实例**

要显示 notes.log 文件的最后 10 行，请输入以下命令：

```
tail notes.log         # 默认显示最后 10 行
```

要跟踪名为 notes.log 的文件的增长情况，请输入以下命令：

```
tail -f notes.log
```

此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。

显示文件 notes.log 的内容，从第 20 行至文件末尾:

```
tail -n +20 notes.log
```

显示文件 notes.log 的最后 10 个字符:

```
tail -c 10 notes.log
```

# 实验3

## chgrp

Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。

与 [chown](https://www.runoob.com/linux/linux-comm-chown.html) 命令不同，chgrp 允许普通用户改变文件所属的组，只要该用户是该组的一员。

在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。

### 语法

```
chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]
```

### 参数说明

**-c 或 --changes**：效果类似"-v"参数，但仅回报更改的部分。

**-f 或 --quiet 或 --silent**： 　不显示错误信息。

**-h 或 --no-dereference**： 　只对符号连接的文件作修改，而不改动其他任何相关文件。

**-R 或 --recursive**： 　递归处理，将指定目录下的所有文件及子目录一并处理。

**-v 或 --verbose**： 　显示指令执行过程。

**--help**： 　在线帮助。

**--reference=<参考文件或目录>**： 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。

**--version**： 　显示版本信息。

### 实例

实例1：改变文件的群组属性：

```
chgrp -v bin log2012.log
```

输出：

```
[root@localhost test]# ll
---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log
[root@localhost test]# chgrp -v bin log2012.log
```

"log2012.log" 的所属组已更改为 bin

```
[root@localhost test]# ll
---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log
```

**说明：** 将 log2012.log 文件由 root 群组改为 bin 群组。

实例2：根据指定文件改变文件的群组属性

```
chgrp --reference=log2012.log log2013.log
```

输出：

```
[root@localhost test]# ll
---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log
-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log
[root@localhost test]#  chgrp --reference=log2012.log log2013.log 
[root@localhost test]# ll
---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log
-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log
```

## chown

Linux chown（英文全拼：**change owner**）命令用于设置文件所有者和文件关联组的命令。

Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 。

chown 需要超级用户 **root** 的权限才能执行此命令。

只有超级用户和属于组的文件所有者才能变更文件关联组。非超级用户如需要设置关联组可能需要使用 [chgrp](https://www.runoob.com/linux/linux-comm-chgrp.html) 命令。

**使用权限** : root

### 语法

```
chown [-cfhvR] [--help] [--version] user[:group] file...
```

**参数** :

- user : 新的文件拥有者的使用者 ID
- group : 新的文件拥有者的使用者组(group)
- -c : 显示更改的部分的信息
- -f : 忽略错误信息
- -h :修复符号链接
- -v : 显示详细的处理信息
- -R : 处理指定目录以及其子目录下的所有文件
- --help : 显示辅助说明
- --version : 显示版本

### 实例

把 /var/run/httpd.pid 的所有者设置 root：

```
chown root /var/run/httpd.pid
```

将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :

```
chown runoob:runoobgroup file1.txt
```

将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:

```
chown -R runoob:runoobgroup *
```

把 /home/runoob 的关联组设置为 512 （关联组ID），不改变所有者：

```
chown :512 /home/runoob
```

## chmod

Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令

Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。

![img](https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg)

只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。

![img](https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png)

**使用权限** : 所有使用者

### 语法

```
chmod [-cfvR] [--help] [--version] mode file...
```

### 参数说明

mode : 权限设定字串，格式如下 :

```
[ugoa...][[+-=][rwxX]...][,...]
```

其中：

- u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。
- \+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。
- r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

其他参数说明：

- -c : 若该文件权限确实已经更改，才显示其更改动作
- -f : 若该文件权限无法被更改也不要显示错误讯息
- -v : 显示权限变更的详细资料
- -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)
- --help : 显示辅助说明
- --version : 显示版本

### 符号模式

使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:

| who  | 用户类型 | 说明                   |
| :--- | :------- | :--------------------- |
| `u`  | user     | 文件所有者             |
| `g`  | group    | 文件所有者所在组       |
| `o`  | others   | 所有其他用户           |
| `a`  | all      | 所有用户, 相当于 *ugo* |

operator 的符号模式表:

| Operator | 说明                                                   |
| :------- | :----------------------------------------------------- |
| `+`      | 为指定的用户类型增加权限                               |
| `-`      | 去除指定用户类型的权限                                 |
| `=`      | 设置指定用户权限的设置，即将用户类型的所有权限重新设置 |

permission 的符号模式表:

| 模式 | 名字         | 说明                                                         |
| :--- | :----------- | :----------------------------------------------------------- |
| `r`  | 读           | 设置为可读权限                                               |
| `w`  | 写           | 设置为可写权限                                               |
| `x`  | 执行权限     | 设置为可执行权限                                             |
| `X`  | 特殊执行权限 | 只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行 |
| `s`  | setuid/gid   | 当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限 |
| `t`  | 粘贴位       | 设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位 |

### 八进制语法

chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。

| #    | 权限           | rwx  | 二进制 |
| :--- | :------------- | :--- | :----- |
| 7    | 读 + 写 + 执行 | rwx  | 111    |
| 6    | 读 + 写        | rw-  | 110    |
| 5    | 读 + 执行      | r-x  | 101    |
| 4    | 只读           | r--  | 100    |
| 3    | 写 + 执行      | -wx  | 011    |
| 2    | 只写           | -w-  | 010    |
| 1    | 只执行         | --x  | 001    |
| 0    | 无             | ---  | 000    |

例如， 765 将这样解释：

- 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。
- 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。
- 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。

### 实例

将文件 file1.txt 设为所有人皆可读取 :

```
chmod ugo+r file1.txt
```

将文件 file1.txt 设为所有人皆可读取 :

```
chmod a+r file1.txt
```

将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :

```
chmod ug+w,o-w file1.txt file2.txt
```

为 ex1.py 文件拥有者增加可执行权限:

```
chmod u+x ex1.py
```

将目前目录下的所有文件与子目录皆设为任何人可读取 :

```
chmod -R a+r *
```

此外chmod也可以用数字来表示权限如 :

```
chmod 777 file
```

语法为：

```
chmod abc file
```

其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。

#### r=4，w=2，x=1

- 若要 rwx 属性则 4+2+1=7；
- 若要 rw- 属性则 4+2=6；
- 若要 r-x 属性则 4+1=5。

```
chmod a=rwx file
```

和

```
chmod 777 file
```

效果相同

```
chmod ug=rwx,o=x file
```

和

```
chmod 771 file
```

效果相同

若用 **chmod 4755 filename** 可使此程序具有 root 的权限。

### 更多说明

| `命令`                                     | 说明                                                         |
| :----------------------------------------- | :----------------------------------------------------------- |
| `chmod a+r *file*`                         | 给file的所有用户增加读权限                                   |
| `chmod a-x *file*`                         | 删除file的所有用户的执行权限                                 |
| `chmod a+rw *file*`                        | 给file的所有用户增加读写权限                                 |
| `chmod +rwx *file*`                        | 给file的所有用户增加读写执行权限                             |
| `chmod u=rw,go= *file*`                    | 对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限） |
| `chmod -R u+r,go-r *docs*`                 | 对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限 |
| `chmod 664 *file*`                         | 对file的所有者和用户组设置读写权限, 为其其他用户设置读权限   |
| `chmod 0755 *file*`                        | 相当于`u=rwx (4+2+1),go=rx (4+1 & 4+1)`。`0` 没有特殊模式。  |
| `chmod 4755 *file*`                        | `4`设置了设置[用户ID](https://www.runoob.com/wiki/用户ID)位，剩下的相当于 u=rwx (4+2+1),go=rx (4+1 & 4+1)。 |
| `find path/ -type d -exec chmod a-x {} \;` | 删除可执行权限对path/以及其所有的目录（不包括文件）的所有用户，使用'-type f'匹配文件 |
| `find path/ -type d -exec chmod a+x {} \;` | 允许所有用户浏览或通过目录path/                              |

## chattr

Linux chattr命令用于改变文件属性。

这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：

1. a：让文件或目录仅供附加用途。
2. b：不更新文件或目录的最后存取时间。
3. c：将文件或目录压缩后存放。
4. d：将文件或目录排除在倾倒操作之外。
5. i：不得任意更动文件或目录。
6. s：保密性删除文件或目录。
7. S：即时更新文件或目录。
8. u：预防意外删除。

### 语法

```
chattr [-RV][-v<版本编号>][+/-/=<属性>][文件或目录...]
```

### 参数

　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。

　　-v<版本编号> 设置文件或目录版本。

　　-V 显示指令执行过程。

　　+<属性> 开启文件或目录的该项属性。

　　-<属性> 关闭文件或目录的该项属性。

　　=<属性> 指定文件或目录的该项属性。

### 实例

用chattr命令防止系统中某个关键文件被修改：

```
chattr +i /etc/resolv.conf
lsattr /etc/resolv.conf
```

会显示如下属性

```
----i-------- /etc/resolv.conf
```

让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：

```
chattr +a /var/log/messages
```

## which

Linux which命令用于查找文件。

which指令会在环境变量$PATH设置的目录里查找符合条件的文件。

### 语法

```
which [文件...]
```

**参数**：

- -n<文件名长度> 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
- -p<文件名长度> 　与-n参数相同，但此处的<文件名长度>包括了文件的路径。
- -w 　指定输出时栏位的宽度。
- -V 　显示版本信息。

### 实例

使用指令"which"查看指令"bash"的绝对路径，输入如下命令：

```
$ which bash
```

上面的指令执行后，输出信息如下所示：

```
/bin/bash                   #bash可执行程序的绝对路径 
```



## find

Linux find 命令用于在指定目录下查找文件和目录。

它可以使用不同的选项来过滤和限制查找的结果。

### 语法

```
find [路径] [匹配条件] [动作]
```

**参数说明** :

**路径** 是要查找的目录路径，可以是一个目录或文件名，也可以是多个路径，多个路径之间用空格分隔，如果未指定路径，则默认为当前目录。

**expression** 是可选参数，用于指定查找的条件，可以是文件名、文件类型、文件大小等等。

匹配条件 中可使用的选项有二三十个之多，以下列出最常用的部份：

- `-name pattern`：按文件名查找，支持使用通配符 `*` 和 `?`。
- `-type type`：按文件类型查找，可以是 `f`（普通文件）、`d`（目录）、`l`（符号链接）等。
- `-size [+-]size[cwbkMG]`：按文件大小查找，支持使用 `+` 或 `-` 表示大于或小于指定大小，单位可以是 `c`（字节）、`w`（字数）、`b`（块数）、`k`（KB）、`M`（MB）或 `G`（GB）。
- `-mtime days`：按修改时间查找，支持使用 `+` 或 `-` 表示在指定天数前或后，days 是一个整数表示天数。
- `-user username`：按文件所有者查找。
- `-group groupname`：按文件所属组查找。

**动作:** 可选的，用于对匹配到的文件执行操作，比如删除、复制等。

find 命令中用于时间的参数如下：

- `-amin n`：查找在 n 分钟内被访问过的文件。
- `-atime n`：查找在 n*24 小时内被访问过的文件。
- `-cmin n`：查找在 n 分钟内状态发生变化的文件（例如权限）。
- `-ctime n`：查找在 n*24 小时内状态发生变化的文件（例如权限）。
- `-mmin n`：查找在 n 分钟内被修改过的文件。
- `-mtime n`：查找在 n*24 小时内被修改过的文件。

在这些参数中，n 可以是一个正数、负数或零。正数表示在指定的时间内修改或访问过的文件，负数表示在指定的时间之前修改或访问过的文件，零表示在当前时间点上修改或访问过的文件。

例如：**-mtime 0** 表示查找今天修改过的文件，**-mtime -7** 表示查找一周以前修改过的文件。

关于时间 n 参数的说明：

- **+n**：查找比 n 天前更早的文件或目录。
- **-n**：查找在 n 天内更改过属性的文件或目录。
- **n**：查找在 n 天前（指定那一天）更改过属性的文件或目录。

### 实例

查找当前目录下名为 file.txt 的文件：

```
find . -name file.txt
```

将当前目录及其子目录下所有文件后缀为 **.c** 的文件列出来:

```
# find . -name "*.c"
```

将当前目录及其子目录中的所有文件列出：

```
# find . -type f
```

查找 /home 目录下大于 1MB 的文件：

```
find /home -size +1M
```

查找 /var/log 目录下在 7 天前修改过的文件：

```
find /var/log -mtime +7
```

在当前目录下查找最近 20 天内状态发生改变的文件和目录:

```
# find . -ctime  20
```

将当前目录及其子目录下所有 20 天前及更早更新过的文件列出:

```
# find . -ctime  +20
```

查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：

```
# find /var/log -type f -mtime +7 -ok rm {} \;
```

查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：

```
# find . -type f -perm 644 -exec ls -l {} \;
```

查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：

```
# find / -type f -size 0 -exec ls -l {} \;
```

找并执行操作（例如删除）：

```
find /path/to/search -name "pattern" -exec rm {} \;
```

这个例子中，**-exec** 选项允许你执行一个命令，**{}** 将会被匹配到的文件名替代，**\;** 表示命令结束。



### 1. 选项 `-name`, `-iname`, `-path`, `-ipath`, `?`, `*`

- 使用 `-name` 查找所有 `.txt` 文件：
  ```bash
  find . -name "*.txt"
  find . -name "example.txt"
  find . -name "config?.txt"
  ```

- 使用 `-iname` 查找不区分大小写的文件名：
  ```bash
  find . -iname "example.txt"
  find . -iname "*.TXT"
  find . -iname "CONFIG?.txt"
  ```

- 使用 `-path` 查找特定路径的文件：
  ```bash
  find /home/user -path "*/documents/*.txt"
  find . -path "*/config/settings.ini"
  find . -path "*/*/cache"
  ```

- 使用 `-ipath` 查找不区分大小写的路径：
  ```bash
  find . -ipath "*/documents/*.txt"
  find . -ipath "*/CONFIG/settings.ini"
  find . -ipath "*/*/CACHE"
  ```

- 使用 `?` 和 `*` 通配符：
  ```bash
  find . -name "file?.txt"     # ? 表示任意单个字符
  find . -name "*.txt"         # * 表示任意长度的字符
  find . -name "data[0-9]*"    # 匹配 data 后跟一个数字和任意字符
  ```

### 2. 选项 `-type`, `-empty`

- 使用 `-type` 查找特定类型的文件：
  ```bash
  find . -type f -name "*.txt"      # 查找所有文本文件
  find . -type d -name "config"      # 查找名为 config 的目录
  find . -type l                     # 查找所有符号链接
  ```

- 使用 `-empty` 查找空文件或目录：
  ```bash
  find . -type f -empty              # 查找空文件
  find . -type d -empty              # 查找空目录
  find . -empty                       # 查找所有空文件和目录
  ```

### 3. 逻辑组合

- 逻辑非 (`!`) 操作：
  ```bash
  find . ! -name "*.txt"             # 查找非文本文件
  find . -type f ! -empty            # 查找非空的文件
  ```

- 逻辑或 (`-o`) 操作：
  ```bash
  find . -name "*.txt" -o -name "*.md"  # 查找文本文件或 Markdown 文件
  find . -type f -empty -o -type d -empty # 查找空文件或空目录
  ```

### 4. 选项 `-delete`, `-exec`

- 使用 `-delete` 删除文件：
  ```bash
  find . -type f -name "*.tmp" -delete  # 删除所有 .tmp 文件
  find . -type d -empty -delete         # 删除所有空目录
  ```

- 使用 `-exec` 执行命令：
  ```bash
  find . -type f -name "*.txt" -exec chmod 644 {} \;  # 更改文本文件的权限
  find . -type f -size +1M -exec gzip {} \;           # 压缩大于1MB的文件
  ```

在进行这些练习时，请确保你对 `find` 命令的使用有足够的理解，特别是在使用 `-delete` 和 `-exec` 选项时，因为它们可以对文件系统进行重大更改。建议先在一个安全的、测试用的目录中练习这些命令。

# 实验4

## groupadd

groupadd 命令用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。

相关文件:

- /etc/group 组账户信息。
- /etc/gshadow 安全组账户信息。
- /etc/login.defs Shadow密码套件配置。

### 语法

groupadd 命令 语法格式如下：

```
groupadd [-g gid [-o]] [-r] [-f] group
```

**参数说明：**

- -g：指定新建工作组的 **id**；
- -r：创建系统工作组，系统工作组的组 ID 小于 500；
- -K：覆盖配置文件 **/etc/login.defs**；
- -o：允许添加组 ID 号不唯一的工作组。
- -f,--force: 如果指定的组已经存在，此选项将失明了仅以成功状态退出。当与 -g 一起使用，并且指定的 GID_MIN 已经存在时，选择另一个唯一的 GID（即 -g 关闭）。

### 实例

创建一个新的组，并添加组 ID。

```
＃groupadd －g 344 runoob
```

此时在 /etc/group 文件中产生一个组 ID（GID）是 344 的项目。

## groupdel

Linux groupdel命令用于删除群组。

需要从系统上删除群组时，可用groupdel(group delete)指令来完成这项工作。倘若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。

### 语法

```
groupdel [群组名称]
```

### 实例

删除一个群组

```
# groupdel hnuser
```

## gzip

Linux gzip命令用于压缩文件。

gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名。

### 语法

```
gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][目录]
```

**参数**：

- -a或--ascii 　使用ASCII文字模式。
- -c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。
- -d或--decompress或----uncompress 　解开压缩文件。
- -f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
- -h或--help 　在线帮助。
- -l或--list 　列出压缩文件的相关信息。
- -L或--license 　显示版本与版权信息。
- -n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。
- -N或--name 　压缩文件时，保存原来的文件名称及时间戳记。
- -q或--quiet 　不显示警告信息。
- -r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
- -S<压缩字尾字符串>或----suffix<压缩字尾字符串> 　更改压缩字尾字符串。
- -t或--test 　测试压缩文件是否正确无误。
- -v或--verbose 　显示指令执行过程。
- -V或--version 　显示版本信息。
- -<压缩效率> 　压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高。
- --best 　此参数的效果和指定"-9"参数相同。
- --fast 　此参数的效果和指定"-1"参数相同。

### 实例

压缩文件

```
[root@runoob.com a]# ls //显示当前目录文件
a.c b.h d.cpp
[root@runoob.com a]# gzip * //压缩目录下的所有文件
[root@runoob.com a]# ls //显示当前目录文件
a.c.gz    b.h.gz    d.cpp.gz
[root@runoob.com a]# 
```

接范例1， 列出详细的信息

```
[root@runoob.com a]# gzip -dv * //解压文件，并列出详细信息
a.c.gz:     0.0% -- replaced with a.c
b.h.gz:     0.0% -- replaced with b.h
d.cpp.gz:     0.0% -- replaced with d.cpp
[root@runoob.com a]# 
```

接范例1，显示压缩文件的信息

```
[root@runoob.com a]# gzip -l *
     compressed    uncompressed ratio uncompressed_name
         24          0  0.0% a.c
         24          0  0.0% b.h
         26          0  0.0% d.cpp
```

## bzip2

Linux bzip2命令是.bz2文件的压缩程序。

bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。

### 语法

```
bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]
```

**参数**：

- -c或--stdout 　将压缩与解压缩的结果送到标准输出。
- -d或--decompress 　执行解压缩。
- -f或--force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。
- -h或--help 　显示帮助。
- -k或--keep 　bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数。
- -s或--small 　降低程序执行时内存的使用量。
- -t或--test 　测试.bz2压缩文件的完整性。
- -v或--verbose 　压缩或解压缩文件时，显示详细的信息。
- -z或--compress 　强制执行压缩。
- -L,--license,
- -V或--version 　显示版本信息。
- --repetitive-best 　若文件中有重复出现的资料时，可利用此参数提高压缩效果。
- --repetitive-fast 　若文件中有重复出现的资料时，可利用此参数加快执行速度。
- -压缩等级 　压缩时的区块大小。

### 实例

解压.bz2文件

```
[root@w3cschool.cc ~]# bzip2 -v temp.bz2 //解压文件显示详细处理信息 
```

压缩文件

```
[root@w3cschool.cc ~]# bzip2 -c a.c b.c c.c
```

检查文件完整性

```
[root@w3cschool.cc ~]# bzip2 -t temp.bz2
```

## xz

xz -help

用法:xz[选项]…[文件]…
压缩或解压.xz格式的文件。
-z，——compress 压缩
-d，——decompress, --uncompress 解压
-t，——test 测试压缩文件的完整性
-l，——list 列出关于.xz文件的列表信息
-k，——keep 保留(不要删除)输入文件
-f，——force 强制重写输出文件和(de)压缩链接
-c，——stdout，——to-stdout 写入标准输出，不要删除输入文件
-0 …-9 压缩预设;默认是6;在使用7-9之前，请考虑压缩机和减压器的内存使用情况!
-e，——extreme 极端尝试提高压缩比使用更多的CPU时间;
不影响解压内存要求
-T，——threads=NUM使用最多的NUM线程;默认值为1;设置为0
使用任意多的处理器内核
-q，——quiet 安静压制警告;指定两次也可以抑制错误
-v，——verbose 啰嗦;如果要更详细，请指定两次
-h，——help 帮助显示此简短的帮助和退出
-H，——long-help 显示long help(同时列出高级选项)
-V，——version 版本显示版本号并退出

## zip

Linux zip 命令用于压缩文件。

zip 是个使用广泛的压缩程序，压缩后的文件后缀名为 **.zip**。

### 语法

```
zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b <工作目录>][-ll][-n <字尾字符串>][-t <日期时间>][-<压缩效率>][压缩文件][文件...][-i <范本样式>][-x <范本样式>]
```

**参数**：

- -A 调整可执行的自动解压缩文件。
- -b<工作目录> 指定暂时存放文件的目录。
- -c 替每个被压缩的文件加上注释。
- -d 从压缩文件内删除指定的文件。
- -D 压缩文件内不建立目录名称。
- -f 更新现有的文件。
- -F 尝试修复已损坏的压缩文件。
- -g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。
- -h 在线帮助。
- -i<范本样式> 只压缩符合条件的文件。
- -j 只保存文件名称及其内容，而不存放任何目录名称。
- -J 删除压缩文件前面不必要的数据。
- -k 使用MS-DOS兼容格式的文件名称。
- -l 压缩文件时，把LF字符置换成LF+CR字符。
- -ll 压缩文件时，把LF+CR字符置换成LF字符。
- -L 显示版权信息。
- -m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。
- -n<字尾字符串> 不压缩具有特定字尾字符串的文件。
- -o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。
- -q 不显示指令执行过程。
- -r 递归处理，将指定目录下的所有文件和子目录一并处理。
- -S 包含系统和隐藏文件。
- -t<日期时间> 把压缩文件的日期设成指定的日期。
- -T 检查备份文件内的每个文件是否正确无误。
- -u 与 -f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。
- -v 显示指令执行过程或显示版本信息。
- -V 保存VMS操作系统的文件属性。
- -w 在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。
- -x<范本样式> 压缩时排除符合条件的文件。
- -X 不保存额外的文件属性。
- -y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。
- -z 替压缩文件加上注释。
- -$ 保存第一个被压缩文件所在磁盘的卷册名称。
- -<压缩效率> 压缩效率是一个介于1-9的数值。

### 实例

将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：

```
zip -q -r html.zip /home/html
```

如果在我们在 /home/html 目录下，可以执行以下命令：

```
zip -q -r html.zip *
```

从压缩文件 cp.zip 中删除文件 a.c

```
zip -dv cp.zip a.c
```

## 详述 yum、apt、dnf，并阐述它们之间的区别

yum、apt 和 dnf 是三种不同的软件包管理器，主要用于在 Linux 操作系统中安装、更新和删除软件。它

们之间的区别主要在于支持的 Linux 发行版和包管理方式。

yum：

yum 是 Red Hat、CentOS 和 Fedora 等发行版中的软件包管理器。它基于 RPM 包管理，可以从指定的服务

器自动下载 RPM 包并安装，能自动处理依赖关系，并一次性安装所有依赖的软件包，无须繁琐地一次次

下载、安装。yum 会自动管理依赖关系，底层调用 rpm 管理软件包。

apt：

apt 是 Debian、Ubuntu 等发行版中的软件包管理器。它是适用于 deb 包管理式的操作系统，主要用于自

动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。

dnf：

dnf 是 Fedora、CentOS 等发行版的新一代 RPM 软件包管理器，全称为 Dandified yum。它在 Fedora 18

版本中首次出现，目前在 Fedora 22 及之后的版本中取代了 yum，成为默认的包管理器。dnf 克服了 yum

的一些瓶颈，提升了包括用户体验、内存占用、依赖分析、运行速度等多方面的内容。dnf 使用 Hawkey

库，该库解析 RPM 依赖性以在客户端计算机上运行查询。 它们基于 libsolv 构建, libsolv 是一种使用

可满足性算法的程序包相关性求解器。

# 实验5

## 1

> 设置环境变量，使.bash_history文件可以保存2000条命令历史。

```bash
echo "export HISTSIZE=2000" >> ~/.bashrc  # ~./bashrc追加内容
echo "export HISTFILESIZE=2000" >> ~/.bashrc # 向~./bashrc追加内容
tail -n 2 ~/.bashrc # 查看~./bashrc最后两行的内容
```

## 2

> 把当前目录下文件的文件名的大写字母替换为小写字母

```bash
$ cat >> script.sh << 'EOL'
#!/bin/bash

for file in *; do
    mv "$file" "$(echo $file | tr 'A-Z' 'a-z')"
done
EOL

$ chmod +x script.sh  # 给该文件添加权限
$ ./script.sh  # 运行该bash脚本
```

## 3

> 针对/ect/passwd文件，自己设计场景，实现sort、cut和管道符|的搭配使用

场景：假设我们想要得到所有用户的用户名和他们的默认 shell，并按照 shell 进行排序

```bash
cat /etc/passwd | cut -d: -f1,7 | sort -t: -k2
```

## 4

> 当前目录下以test开头的文件和目录列出。

```bash
ls test*
```

## 5

> 把一个命令的输出内容打印到屏幕，同时重定向到一个文件内

```bash
echo "hello world" | tee -a hello.txt  # 把一个命令的输出内容打印到屏幕，同时重定向到一个文件内
cat < hello.txt  # 查看文件中是否输入了内容
```

## 6

> 假设我们有以下长命令，它查找所有 .txt 文件，计算这些文件的行数，并将结果输出到 line_counts.txt 文件中, 我们可以为上述长命令创建一个简短的别名，如 counttxt,这样输入counttxt就可以快速计算行数

```bash
find . -name "*.txt" -exec wc -l {} \; > ./line_counts.txt
alias counttxt='find . -name "*.txt" -exec wc -l {} \; > ./line_counts.txt'  # 给该指令取别名counttxt

```

## 7

> 创建一个名为 project 的目录。如果成功创建目录，将在其中创建一个名为 data.txt 的空文件。在 mkdir 命令失败时（例如，因为 project 目录已存在）打印一个错误消息不论之前的命令是否成功，你都希望在终端中打印出 "Script executed!"。

```bash
mkdir project && touch project/data.txt || echo "Failed to create directory!" ; echo "Script executed!"

```

## 8 进程

进程简介：

在 Linux 中，一个进程是一个运行中的程序的实例。每个进程都有一个独特的进程 ID (PID)。

进程的状态：

运行态 (Running)：进程正在执行或在等待执行。

中断态 (Interruptible sleep)：进程正在等待某些条件成真，例如等待 I/O 操作完成。

不可中断态 (Uninterruptible sleep)：进程在等待某些特定条件，但不能被其他事件中断。

僵尸态 (Zombie)：进程已结束，但其父进程还没有获取其退出状态。

停止态 (Stopped)：进程已停止，不再执行。

进程管理命令：

ps: 显示当前进程状态。

top: 动态显示进程状态。

pstree: 显示进程树。

kill: 向进程发送信号。

nice 和 renice: 调整进程优先级。

进程的创建和终止：

fork()：创建一个新的子进程，这是最常用的进程创建方法。

exec()：在当前进程上下文中执行一个新程序。

wait()：父进程等待子进程终止。

exit()：结束进程执行。

后台和前台进程：

在 Linux 中，可以使用 & 将进程放到后台运行。

fg 命令可以将后台进程调到前台。

bg 命令可以将停止的进程放到后台运行。

## 9Linux 环境变量综述，介绍和总结

环境变量简介：

环境变量在 Linux 中是存储系统设置和应用程序配置的键值对。它们可以被 shell 和程序使用。

常见的环境变量：

PATH: 定义命令查找路径。

HOME: 用户的主目录。

USER: 当前登录的用户名。

PS1: shell 提示符。

LD_LIBRARY_PATH: 动态链接库查找路径。

设置和显示环境变量：

export: 设置环境变量。例如：export VARNAME=value。

unset: 删除环境变量。

printenv: 显示环境变量。

env: 列出所有环境变量。

配置文件：

在 Linux 中，有多个文件和目录用于配置环境变量：

/etc/environment: 系统范围内的环境变量。

/etc/profile 和 /etc/profile.d/*: 系统范围内的 shell 启动脚本。

~/.bashrc 和 ~/.bash_profile: 用户级别的 shell 启动脚本

# 实验6

实验报告内容:

## 1. 工具grep的实验报告

### **命令要求**：

> 涉及到书本上P154-155共7个命令 + 2个额外命令(课外查找)。

```shell
# 书本上的命令
grep -c 'pattern' filename # 计算文件filename中包含字符串pattern的行数
grep -i 'pattern' filename # 搜索文件filename中包含pattern的行，不区分大小写
grep -n 'pattern' filename # 显示文件filename中每一个包含pattern的行及其行号
grep -v 'pattern' filename # 显示文件filename中所有不包含pattern的行
grep -A 2 'pattern' filename # 显示文件filename中每一个包含pattern的行，以及紧随其后的两行
grep -B 2 'pattern' filename # 显示文件filename中每一个包含pattern的行，以及其前面的两行
grep -C 2 'pattern' filename # 显示文件filename中每一个包含pattern的行，以及其前后各两行的内容
# 课外查找的额外命令
grep -E 'end$' filename # 使用扩展正则表达式匹配任何以'end'结尾的行
grep -V # 显示版本信息
```

### **功能要求**：

> 涉及到书本上P155-158(也就是11.1.1-11.1.8所有的功能) + 2个额外功能(课外查找)，每个功能要体现3次(不能与书上例子一样)。

```shell
grep -n "std" 1.cc # 过滤出带有某个关键词的行，并输出行号
grep -nv "std" 1.cc # 过滤出不带有某个关键词的行，并输出行号
grep [0-9] 1.cc # 过滤出所有带数字的行
grep -v [0-9] 1.cc # 过滤出所有不带数字的行
grep -v '^#' 1.cc # 过滤掉所有以#开头的行
grep -v "^#" 1.cc | grep -v "^$" # 过滤掉所有空行和以#开头的行
grep "s.d" 1.cc # 过滤出任意一个字符和重复字符
grep "(std)*" 1.cc # 过滤出含有零个或多个std
egrep ":+" 1.cc # 过滤出一个或多个:
egrep ":?" 1.cc # 过滤出零或一个:
grep -v [0-9] *1* # 查找文件名中包含 1 的文件中不包含数字的行
```

```shell
cat >> script.sh << "EOF"
#!/bin/bash

# 过滤出带有某个关键词的行，并输出行号
echo "Command: grep -n \"std\" 1.cc # 过滤出带有某个关键词的行，并输出行号"
grep -n "std" 1.cc

# 过滤出不带有某个关键词的行，并输出行号
echo "Command: grep -nv \"std\" 1.cc # 过滤出不带有某个关键词的行，并输出行号"
grep -nv "std" 1.cc

# 过滤出所有带数字的行
echo "Command: grep [0-9] 1.cc # 过滤出所有带数字的行"
grep [0-9] 1.cc

# 过滤出所有不带数字的行
echo "Command: grep -v [0-9] 1.cc # 过滤出所有不带数字的行"
grep -v [0-9] 1.cc

# 过滤掉所有以#开头的行
echo "Command: grep -v '^#' 1.cc # 过滤掉所有以#开头的行"
grep -v '^#' 1.cc

# 过滤掉所有空行和以#开头的行
echo "Command: grep -v \"^#\" 1.cc | grep -v \"^$\" # 过滤掉所有空行和以#开头的行"
grep -v "^#" 1.cc | grep -v "^$"

# 过滤出任意一个字符和重复字符
echo "Command: grep \"s.d\" 1.cc # 过滤出任意一个字符和重复字符"
grep "s.d" 1.cc

# 过滤出含有零个或多个std
echo "Command: grep \"(std)*\" 1.cc # 过滤出含有零个或多个std"
grep "(std)*" 1.cc

# 过滤出一个或多个:
echo "Command: egrep \":+\" 1.cc # 过滤出一个或多个:"
egrep ":+" 1.cc

# 过滤出零或一个:
echo "Command: egrep \":?\" 1.cc # 过滤出零或一个:"
egrep ":?" 1.cc

# 查找文件名中包含 1 的文件中不包含数字的行
echo "Command: grep -v [0-9] *1* # 查找文件名中包含 1 的文件中不包含数字的行"
grep -v [0-9] *1*
EOF

chmod +x script.sh
./script.sh
```

### **区别阐述**：

> 阐述grep和egrep的联系与区别，并列举3个例子，示例这种区别(不能与书上例子一样)。
> `grep` 和 `egrep` 都是 Linux 中用于在文件中搜索特定模式的命令。它们的主要区别在于它们处理正则表达式的方式。

- `grep`：`grep` 命令使用基本正则表达式进行搜索。在基本正则表达式中，一些元字符（如 `+`、`?`、`|` 等）需要使用反斜杠 (`\`) 进行转义才能发挥其特殊功能。

- `egrep`：`egrep` 是 `grep -E` 的快捷方式，它使用扩展正则表达式进行搜索。在扩展正则表达式中，元字符无需转义即可发挥其特殊功能。

下面是一些例子来说明这种区别：

1. **使用 `grep` 搜索以 'a' 或 'b' 结尾的行**：

	```shell
	grep 'a\\|b$' filename
	```

	这将返回文件中以 'a' 或 'b' 结尾的所有行。

2. **使用 `egrep` 执行相同的搜索**：

	```shell
	egrep 'a|b$' filename
	```

	这将返回与 `grep` 相同的结果，但是我们不需要使用反斜杠转义 `|` 字符。

3. **使用 `grep` 搜索包含字符串 'a|b' 的行**：

	```shell
	grep 'a|b' filename
	```

	这将返回文件中包含字符串 'a|b' 的所有行。

## 2. 工具sed的初步掌握

### **要求**：

> 涉及到书本上P160-163(也就是11.2.1-11.2.6所有的功能)，每个功能要体现3次(不能与书上例子一样)。

将指令输入到sed_script.sh中

```shell
cat >> sed_script.sh << "EOF"
echo "打印某行，这里分别打印第2、第3和第4行"
sed -n '2p' 1.cc
sed -n '3p' 1.cc
sed -n '4p' 1.cc

echo "打印包含某个字符串的行，这里分别打印包含"root"、"user"和"bin"的行"
sed -n '/root/p' 1.cc
sed -n '/user/p' 1.cc
sed -n '/bin/p' 1.cc

echo "删除某些行，这里分别删除第5、第6和第7行"
sed '5d' 1.cc
sed '6d' 1.cc
sed '7d' 1.cc

echo "替换字符或字符串，这里分别将"root"替换为"user"，"bin"替换为"dev"，以及"/bin/bash"替换为"/usr/bin/zsh""
sed 's/root/user/' 1.cc
sed 's/bin/dev/' 1.cc
sed 's/\/bin\/bash/\/usr\/bin\/zsh/' 1.cc

echo "调换两个字符串的位置，这里分别调换"x:0:0:root"与"root:x:0:0"、"usr:bin"与"bin:usr"、"dev:sbin"与"sbin:dev"的位置"
sed 's/\(x:0:0:\)root/root:\1/' 1.cc
sed 's/\(usr:\)bin/bin:\1/' 1.cc
sed 's/\(dev:\)sbin/sbin:\1/' 1.cc

echo "直接修改文件的内容，这里分别将文件中的"root"替换为"user"，"bin"替换为"dev"，以及"/bin/bash"替换为"/usr/bin/zsh""
sed -i 's/root/user/' 1.cc
sed -i 's/bin/dev/' 1.cc
sed -i 's/\/bin\/bash/\/usr\/bin\/zsh/' 1.cc
EOF
```

给sed_script.sh运行权限

```shell
chmod +x sed_script.sh
```

运行该脚本

```shell
./sed_script.sh
```

## 3. 工具sed的深度掌握

### **要求**：

> 探索书本之外的3个额外功能，每个功能要体现3次。

```shell
cat >> sed_extra_script.sh << "EOF"
echo "插入文本到特定行后"
sed '1a New Line 1' ./passwd
sed '2a New Line 2' ./passwd
sed '3a New Line 3' ./passwd

echo "在特定行前添加文本"
sed '1i Header 1' ./passwd
sed '2i Header 2' ./passwd
sed '3i Header 3' ./passwd

echo "选择性地打印模式空间内容"
sed -n '/^start/p' ./passwd
sed -n '/end$/p' ./passwd
sed -n '/^start/!;/end$/!p' ./passwd
EOF
```

## 4. 工具awk的实验报告

### **要求**：

> 11.3.1-11.3.3的功能都要涉及到，每个功能要体现3次。

```shell
cat  >> awk_script.sh << "EOF"
#!/bin/bash

# 截取文档中的某个段
echo "截取前三行"
awk 'NR>=1 && NR<=3' ./passwd

echo "截取用户名为 'daemon' 和 'bin' 之间的行"
awk '/daemon/,/bin/' ./passwd

echo "截取用户名字段"
awk -F':' '{print $1}' ./passwd

# 匹配字符或字符串
echo "匹配含有 'nologin' 的行"
awk '/nologin/' ./passwd

echo "匹配 UID 为 100 的用户"
awk -F':' '$3==100' ./passwd

echo "匹配含有 'nologin' 并打印用户名和shell"
awk -F':' '/nologin/ {print $1, $NF}' ./passwd

# 条件操作符
echo "打印 UID 小于 10 的用户"
awk -F':' '$3<10 {print $1}' ./passwd

echo "打印 UID 大于 100 且使用 '/bin/bash' 的用户"
awk -F':' '$3>100 && $NF=="/bin/bash" {print $1}' ./passwd

echo "打印 GID 在 100 至 200 范围内的用户"
awk -F':' '$4>=100 && $4<=200 {print $1}' ./passwd
EOF
```

## 5. grep\egrep\sed\awk\vim的介绍和区别

> 结合书上内容与课外资料进行介绍和比较。

`grep`、`egrep`、`sed`、`awk`和`vim`都是在Linux中用于处理文本的强大工具，每个工具都有其特定的用途和功能。

- `grep`：`grep`是一个用于在文件或输入流中查找匹配正则表达式的行并将这些匹配行打印到标准输出的工具。它是最简单的工具，主要用于简单的文本匹配和打印。

- `egrep`：`egrep`是`grep`的扩展版本，它提供了与`grep -E`相同的输出，但工作速度更快⁵。它可以处理文本并执行比较和算术运算。

- `sed`：`sed`可以查找和修改数据，但其语法比`grep`稍微复杂一些。它是一个流编辑器，可以对输入流（文件或管道输入）进行转换。

- `awk`：`awk`是一种完整的编程语言，可以处理文本并执行比较和算术运算。它是一个用于处理文本的脚本语言，提供了许多`grep`和`sed`中不存在的功能。

- `vim`：`vim`是一个文本编辑器，它是Vi编辑器的增强版本，通常在命令行界面中使用，但也有可用于标准桌面使用的GUI版本。


## 6. grep\egrep\sed\awk\vim涉及到的特殊字符的总结和比较

`grep`、`egrep`、`sed`、`awk`和`vim`都是在Linux中用于处理文本的强大工具，每个工具都有其特定的用途和功能。以下是这些工具中涉及到的一些特殊字符的总结和比较：

- `grep`：`grep`是一个用于在文件或输入流中查找匹配正则表达式的行并将这些匹配行打印到标准输出的工具。它是最简单的工具，主要用于简单的文本匹配和打印。在`grep`中，有一些特殊字符需要转义，例如`$`、`*`、`|`、`^`、`(`、`)`和`]`。

- `egrep`：`egrep`是`grep`的扩展版本，它提供了与`grep -E`相同的输出，但工作速度更快²⁶。它可以处理文本并执行比较和算术运算²³。在`egrep`中，也有一些特殊字符需要转义，例如`$`、`*`、`|`、`^`、`(`、`)`和`]`。

- `sed`：`sed`可以查找和修改数据，但其语法比`grep`稍微复杂一些²³。它是一个流编辑器，可以对输入流（文件或管道输入）进行转换。在`sed`中，有一些特殊字符需要转义，例如`$`、`*`、`|`、`^`、`(`、`)`和`]`[^10^]。

- `awk`：`awk`是一种完整的编程语言，可以处理文本并执行比较和算术运算。它是一个用于处理文本的脚本语言，提供了许多`grep`和`sed`中不存在的功能。在`awk`中，有一些特殊字符需要转义，例如`$`、`*`、`|`、`^`、`(`、`)`和`]`。

- `vim`：`vim`是一个文本编辑器，它是Vi编辑器的增强版本，通常在命令行界面中使用，但也有可用于标准桌面使用的GUI版本。在`vim`中，有一些特殊字符需要转义，例如`$`、`*`、`|`、`^`、`(`、`)`和`]`[^20^]。


## 7. 命令解释与实践验证

- `$ awk -F: '{print $1,$5}' file.txt`
- `$ awk -F'[:\t]' '{print $1,$3}' file.txt`
- `$ awk -F: '{print $1,$5}' file.txt`
- `$ awk '{print $3}' file.txt`
- `$ awk '/^(no|so)/' file.txt`
- `$ awk '/^[ns]/{print $1}' file.txt`
- `$ awk '$1 ~/[0-9][0-9]$/(print $1}' file.txt`
- `$ awk '$1 == 100 || $2 < 50' file.txt`
- `$ awk '/test/{print $1 + 10}' file.txt`
- `$ awk '$1 ~/test/{count = $2 + $3; print count}' file.txt`
- `$ awk -F: '{IGNORECASE=1; $1 == "MARY"{print NR,$1,$2,$NF}' file.txt`
- `$ awk {name[x++]=$2};END{for(i=0;i<NR;i++) print i,name[i]}' file.txt`
- `$ awk '{count[$1]++} END{for(name in count) print name,count[name]}' file.txt`
- `$ awk '{line[x++]=$1} END{for(x in line) delete(line[x])}' file.txt`

```shell
# 打印以':'分隔的第一个和第五个字段
$ awk -F: '{print $1,$5}' file.txt

# 打印以':'或制表符分隔的第一个和第三个字段
$ awk -F'[:\t]' '{print $1,$3}' file.txt

# 打印以':'分隔的第一个和第五个字段
$ awk -F: '{print $1,$5}' file.txt

# 打印每行的第三个字段
$ awk '{print $3}' file.txt

# 打印以'no'或'so'开头的行
$ awk '/^(no|so)/' file.txt

# 打印以'n'或's'开头的行的第一个字段
$ awk '/^[ns]/{print $1}' file.txt

# 如果第一个字段以两位数字结尾，则打印第一个字段
$ awk '$1 ~ /[0-9][0-9]$/ {print $1}' file.txt

# 打印第一个字段等于100或第二个字段小于50的行
$ awk '$1 == 100 || $2 < 50' file.txt

# 对于包含'test'的行，打印第一个字段加10
$ awk '/test/{print $1 + 10}' file.txt

# 如果第一个字段包含'test'，则打印第二个字段和第三个字段的和
$ awk '$1 ~/test/ {count = $2 + $3; print count}' file.txt

# 对于第一个字段为"MARY"（不区分大小写）的行，打印行号、第一个字段、第二个字段和最后一个字段
$ awk -F: '{IGNORECASE=1; $1 == "MARY" {print NR,$1,$2,$NF}}' file.txt

# 将第二个字段存储在数组'name'中，并在结束时打印它们
$ awk '{name[x++]=$2} ; END {for(i=0; i<NR; i++) print i,name[i]}' file.txt

# 统计第一个字段的出现次数，并在结束时打印名称和计数
$ awk '{count[$1]++} END {for(name in count) print name,count[name]}' file.txt

# 在结束时删除存储第一个字段的'line'数组的元素
$ awk '{line[x++]=$1} END {for(x in line) delete(line[x])}' file.txt

```

执行这些指令:

```shell
cat >> awk_script.sh << "EOF"
#!/bin/bash

# 打印并执行 AWK 命令
echo "\$ awk -F: '{print \$1,\$5}' file.txt"
awk -F: '{print $1,$5}' file.txt

echo "\$ awk -F'[:\t]' '{print \$1,\$3}' file.txt"
awk -F'[:\t]' '{print $1,$3}' file.txt

echo "\$ awk '{print \$3}' file.txt"
awk '{print $3}' file.txt

echo "\$ awk '/^(no|so)/' file.txt"
awk '/^(no|so)/' file.txt

echo "\$ awk '/^[ns]/{print \$1}' file.txt"
awk '/^[ns]/{print $1}' file.txt

echo "\$ awk '\$1 ~/[0-9][0-9]$/(print \$1}' file.txt"
awk '$1 ~/[0-9][0-9]$/(print $1}' file.txt

echo "\$ awk '\$1 == 100 || \$2 < 50' file.txt"
awk '$1 == 100 || $2 < 50' file.txt

echo "\$ awk '/test/{print \$1 + 10}' file.txt"
awk '/test/{print $1 + 10}' file.txt

echo "\$ awk '\$1 ~/test/{count = \$2 + \$3; print count}' file.txt"
awk '$1 ~/test/{count = $2 + $3; print count}' file.txt

echo "\$ awk -F: '{IGNORECASE=1; \$1 == \"MARY\"{print NR,\$1,\$2,\$NF}' file.txt"
awk -F: '{IGNORECASE=1; $1 == "MARY"{print NR,$1,$2,$NF}' file.txt

echo "\$ awk '{name[x++]=\$2};END{for(i=0;i<NR;i++) print i,name[i]}' file.txt"
awk '{name[x++]=$2};END{for(i=0;i<NR;i++) print i,name[i]}' file.txt

echo "\$ awk '{count[\$1]++} END{for(name in count) print name,count[name]}' file.txt"
awk '{count[$1]++} END{for(name in count) print name,count[name]}' file.txt

echo "\$ awk '{line[x++]=\$1} END{for(x in line) delete(line[x])}' file.txt"
awk '{line[x++]=$1} END{for(x in line) delete(line[x])}' file.txt

EOF

chmod +x awk_script.sh

./awk_script.sh
```

向file.txt中输入内容

```bash
cat >> file.txt << "EOF"
std::vector<int> v;
# 这是一个注释行
nobody expects the Spanish Inquisition
so it begins
12345
line with 99 at the end99
100, first field is 100
42, this field is less than 50
This line contains the word test
A test line with numbers: 10, 20
s.d sequence in this line
stdstd repeated sequence
one colon: here
two colons:: here
line with numbers 1, 2, 3
line without numbers
EOF
```




## 8. 命令cd\mkdir\rm\cp\mv\cat\chmod的复习

### **概述**：

> 结合书上内容，概况阐述总结每个命令。

这些命令都是在Unix或类Unix系统（比如Linux和macOS）中常用的命令行工具，用于进行文件和目录的管理。下面是每个命令的英文名称和它们的基本功能：

1. `cd` (Change Directory): 用于更改当前工作目录。例如 `cd /home` 会将当前目录切换到 `/home`。

2. `mkdir` (Make Directory): 用于创建新的目录。例如 `mkdir new_folder` 会在当前目录下创建一个名为 `new_folder` 的新目录。

3. `rm` (Remove): 用于删除文件或目录。例如 `rm file.txt` 会删除名为 `file.txt` 的文件。如果配合 `-r` 标志（递归），它也可以删除目录及其包含的所有文件。

4. `cp` (Copy): 用于复制文件或目录。例如 `cp source.txt destination.txt` 会将 `source.txt` 文件复制到 `destination.txt`。

5. `mv` (Move): 用于移动或重命名文件或目录。例如 `mv old_name.txt new_name.txt` 会将 `old_name.txt` 重命名为 `new_name.txt`。

6. `cat` (Concatenate): 通常用于查看、创建和合并文件。例如 `cat file.txt` 会在终端显示 `file.txt` 文件的内容。

7. `chmod` (Change Mode): 用于改变文件或目录的权限。例如 `chmod 755 file.txt` 会将 `file.txt` 的权限设置为所有者可读写执行、组和其他用户可读执行。

### **实践操作**：

> 实践操作每个命令2次。

```shell
cd .
cd ~

mkdir Directory
mkdir -p project/src

rm 1.txt
rm -r test/

cp 1.txt 2.txt
cp -r folder1 folder2

mv file1.txt file2.txt
mv folder1 folder2

cat file.txt
cat file1.txt file2.txt > combined.txt

chmod 644 file.txt
chmod +x script.sh

```

## grep

Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。

grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。

### 语法

```
grep [options] pattern [files]
或
grep [-abcEFGhHilLnqrsvVwxy][-A<显示行数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]
```

- pattern - 表示要查找的字符串或正则表达式。
- files - 表示要查找的文件名，可以同时查找多个文件，如果省略 files 参数，则默认从标准输入中读取数据。

**常用选项：**：

- `-i`：忽略大小写进行匹配。
- `-v`：反向查找，只打印不匹配的行。
- `-n`：显示匹配行的行号。
- `-r`：递归查找子目录中的文件。
- `-l`：只打印匹配的文件名。
- `-c`：只打印匹配的行数。

**更多参数说明**：

- **-a 或 --text** : 不要忽略二进制的数据。
- **-A<显示行数> 或 --after-context=<显示行数>** : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
- **-b 或 --byte-offset** : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
- **-B<显示行数> 或 --before-context=<显示行数>** : 除了显示符合样式的那一行之外，并显示该行之前的内容。
- **-c 或 --count** : 计算符合样式的列数。
- **-C<显示行数> 或 --context=<显示行数>或-<显示行数>** : 除了显示符合样式的那一行之外，并显示该行之前后的内容。
- **-d <动作> 或 --directories=<动作>** : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
- **-e<范本样式> 或 --regexp=<范本样式>** : 指定字符串做为查找文件内容的样式。
- **-E 或 --extended-regexp** : 将样式为延伸的正则表达式来使用。
- **-f<规则文件> 或 --file=<规则文件>** : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
- **-F 或 --fixed-regexp** : 将样式视为固定字符串的列表。
- **-G 或 --basic-regexp** : 将样式视为普通的表示法来使用。
- **-h 或 --no-filename** : 在显示符合样式的那一行之前，不标示该行所属的文件名称。
- **-H 或 --with-filename** : 在显示符合样式的那一行之前，表示该行所属的文件名称。
- **-i 或 --ignore-case** : 忽略字符大小写的差别。
- **-l 或 --file-with-matches** : 列出文件内容符合指定的样式的文件名称。
- **-L 或 --files-without-match** : 列出文件内容不符合指定的样式的文件名称。
- **-n 或 --line-number** : 在显示符合样式的那一行之前，标示出该行的列数编号。
- **-o 或 --only-matching** : 只显示匹配PATTERN 部分。
- **-q 或 --quiet或--silent** : 不显示任何信息。
- **-r 或 --recursive** : 此参数的效果和指定"-d recurse"参数相同。
- **-s 或 --no-messages** : 不显示错误信息。
- **-v 或 --invert-match** : 显示不包含匹配文本的所有行。
- **-V 或 --version** : 显示版本信息。
- **-w 或 --word-regexp** : 只显示全字符合的列。
- **-x --line-regexp** : 只显示全列符合的列。
- **-y** : 此参数的效果和指定"-i"参数相同。

[![Linux 命令大全](https://www.runoob.com/images/up.gif) Linux 命令大全](https://www.runoob.com/linux/linux-command-manual.html)

### 实例

1、在文件 file.txt 中查找字符串 "hello"，并打印匹配的行：

```
grep hello file.txt
```

2、在文件夹 dir 中递归查找所有文件中匹配正则表达式 "pattern" 的行，并打印匹配行所在的文件名和行号：

```
grep -r -n pattern dir/
```

3、在标准输入中查找字符串 "world"，并只打印匹配的行数：

```
echo "hello world" | grep -c world
```

4、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：

```
grep test *file 
```

结果如下所示：

```
$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  
testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  
testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  
testfile_2:Linux test #列出testfile_2 文件中包含test字符的行 
```

5、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串"update"的文件，并打印出该字符串所在行的内容，使用的命令为：

```
grep -r update /etc/acpi 
```

输出结果如下：

```
$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi”  
#下包含“update”的文件  
/etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  
Rather than  
/etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of  
IO.) Rather than  
/etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update 
```

6、反向查找。前面各个例子是查找并打印出符合条件的行，通过"-v"参数可以打印出不符合条件行的内容。

查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：

```
grep -v test *test*
```

结果如下所示：

```
$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  
testfile1:helLinux!  
testfile1:Linis a free Unix-type operating system.  
testfile1:Lin  
testfile_1:HELLO LINUX!  
testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  
testfile_1:THIS IS A LINUX TESTFILE!  
testfile_2:HELLO LINUX!  
testfile_2:Linux is a free unix-type opterating system.  
```

## sed

Linux sed 命令是利用脚本来处理文本文件。

sed 可依照脚本的指令来处理、编辑文本文件。

Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。

### 语法

```
sed [-hnV][-e<script>][-f<script文件>][文本文件]
```

**参数说明**：

- -e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。
- -f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。
- -h或--help 显示帮助。
- -n或--quiet或--silent 仅显示script处理后的结果。
- -V或--version 显示版本信息。

**动作说明**：

- a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
- c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
- d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；
- i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
- p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
- s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！例如 1,20s/old/new/g 就是啦！

### 实例

我们先创建一个 **testfile** 文件，内容如下：

```
$ cat testfile #查看testfile 中的内容  
HELLO LINUX!  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test 
Google
Taobao
Runoob
Tesetfile
Wiki
```

在 **testfile** 文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令：

```
sed -e 4a\newLine testfile 
```

使用 **sed** 命令后，输出结果如下：

```
$ sed -e 4a\newLine testfile 
HELLO LINUX!  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test 
newLine
Google
Taobao
Runoob
Tesetfile
Wiki
```

### 以行为单位的新增/删除

将 **testfile** 的内容列出并且列印行号，同时，请将第 2~5 行删除！

```
$ nl testfile | sed '2,5d'
     1  HELLO LINUX!  
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

sed 的动作为 **2,5d**，那个 **d** 是删除的意思，因为删除了 2-5 行，所以显示的数据就没有 2-5 行了， 另外，原本应该是要下达 sed -e 才对，但没有 -e 也是可以的，同时也要注意的是， sed 后面接的动作，请务必以 **'...'** 两个单引号括住喔！

只要删除第 2 行：

```
$ nl testfile | sed '2d' 
     1  HELLO LINUX!  
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

要删除第 3 到最后一行：

```
$ nl testfile | sed '3,$d' 
     1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
```

在第二行后(即加在第三行) 加上**drink tea?** 字样：

```
$ nl testfile | sed '2a drink tea'
     1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
drink tea
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

如果是要在第二行前，命令如下：

```
$ nl testfile | sed '2i drink tea' 
     1  HELLO LINUX!  
drink tea
     2  Linux is a free unix-type opterating system.  
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

如果是要增加两行以上，在第二行后面加入两行字，例如 **Drink tea or .....** 与 **drink beer?**

```
$ nl testfile | sed '2a Drink tea or ......\
drink beer ?'

1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
Drink tea or ......
drink beer ?
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

每一行之间都必须要以反斜杠 **\** 来进行新行标记。上面的例子中，我们可以发现在第一行的最后面就有 **\** 存在。

### 以行为单位的替换与显示

将第 **2-5** 行的内容取代成为 **No 2-5 number** 呢？

```
$ nl testfile | sed '2,5c No 2-5 number'
     1  HELLO LINUX!  
No 2-5 number
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

透过这个方法我们就能够将数据整行取代了。

仅列出 testfile 文件内的第 5-7 行：

```
$ nl testfile | sed -n '5,7p'
     5  Google
     6  Taobao
     7  Runoob
```

可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。

### 数据的搜寻并显示

搜索 testfile 有 **oo** 关键字的行:

```
$ nl testfile | sed -n '/oo/p'
     5  Google
     7  Runoob
```

如果 root 找到，除了输出所有行，还会输出匹配行。

### 数据的搜寻并删除

删除 testfile 所有包含 **oo** 的行，其他行输出

```
$ nl testfile | sed  '/oo/d'
     1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
     3  This is a linux testfile!  
     4  Linux test 
     6  Taobao
     8  Tesetfile
     9  Wiki
```

### 数据的搜寻并执行命令

搜索 testfile，找到 **oo** 对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把 **oo** 替换为 **kk**，再输出这行：

```
$ nl testfile | sed -n '/oo/{s/oo/kk/;p;q}'  
     5  Gkkgle
```

最后的 **q** 是退出。

### 数据的查找与替换

除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的查找与替换<。

sed 的查找与替换的与 **vi** 命令类似，语法格式如下：

```
sed 's/要被取代的字串/新的字串/g'
```

将 testfile 文件中每行第一次出现的 oo 用字符串 kk 替换，然后将该文件内容输出到标准输出:

```
sed -e 's/oo/kk/' testfile
```

**g** 标识符表示全局查找替换，使 sed 对文件中所有符合的字符串都被替换，修改后内容会到标准输出，不会修改原文件：

```
sed -e 's/oo/kk/g' testfile
```

选项 **i** 使 sed 修改文件:

```
sed -i 's/oo/kk/g' testfile
```

批量操作当前目录下以 **test** 开头的文件：

```
sed -i 's/oo/kk/g' ./test*
```

接下来我们使用 /sbin/ifconfig 查询 IP：

```
$ /sbin/ifconfig eth0
eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84
inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
.....(以下省略).....
```

本机的 ip 是 192.168.1.100。

将 IP 前面的部分予以删除：

```
$ /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g'
192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
```

接下来则是删除后续的部分，即：**192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0**。

将 IP 后面的部分予以删除:

```
$ /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g'
192.168.1.100
```

### 多点编辑

一条 sed 命令，删除 testfile 第三行到末尾的数据，并把 HELLO 替换为 RUNOOB :

```
$ nl testfile | sed -e '3,$d' -e 's/HELLO/RUNOOB/'
     1  RUNOOB LINUX!  
     2  Linux is a free unix-type opterating system.  
```

-e 表示多点编辑，第一个编辑命令删除 testfile 第三行到末尾的数据，第二条命令搜索 HELLO 替换为 RUNOOB。

### 直接修改文件内容(危险动作)

sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由于这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用文件 regular_express.txt 文件来测试看看吧！

regular_express.txt 文件内容如下：

```
$ cat regular_express.txt 
runoob.
google.
taobao.
facebook.
zhihu-
weibo-
```

利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !

```
$ sed -i 's/\.$/\!/g' regular_express.txt
$ cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-
```

:q:q

利用 sed 直接在 regular_express.txt 最后一行加入 **# This is a test**:

```
$ sed -i '$a # This is a test' regular_express.txt
$ cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-
# This is a test
```

由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增 **# This is a test**！

sed 的 **-i** 选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！

## awk

AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。

之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。

### 语法

```
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
```

**选项参数说明：**

- -F fs or --field-separator fs
	指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。
- -v var=value or --asign var=value
	赋值一个用户定义变量。
- -f scripfile or --file scriptfile
	从脚本文件中读取awk命令。
- -mf nnn and -mr nnn
	对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。
- -W compact or --compat, -W traditional or --traditional
	在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。
- -W copyleft or --copyleft, -W copyright or --copyright
	打印简短的版权信息。
- -W help or --help, -W usage or --usage
	打印全部awk选项和每个选项的简短说明。
- -W lint or --lint
	打印不能向传统unix平台移植的结构的警告。
- -W lint-old or --lint-old
	打印关于不能向传统unix平台移植的结构的警告。
- -W posix
	打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。
- -W re-interval or --re-inerval
	允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。
- -W source program-text or --source program-text
	使用program-text作为源代码，可与-f命令混用。
- -W version or --version
	打印bug报告信息的版本。

------

## 基本用法

log.txt文本内容如下：

```
2 this is a test
3 Do you like awk
This's a test
10 There are orange,apple,mongo
```

用法一：

```
awk '{[pattern] action}' {filenames}   # 行匹配语句 awk '' 只能用单引号
```

实例：

```
# 每行按空格或TAB分割，输出文本中的1、4项
 $ awk '{print $1,$4}' log.txt
 ---------------------------------------------
 2 a
 3 like
 This's
 10 orange,apple,mongo
 # 格式化输出
 $ awk '{printf "%-8s %-10s\n",$1,$4}' log.txt
 ---------------------------------------------
 2        a
 3        like
 This's
 10       orange,apple,mongo
 
```

用法二：

```
awk -F  #-F相当于内置变量FS, 指定分割字符
```

实例：

```
# 使用","分割
 $  awk -F, '{print $1,$2}'   log.txt
 ---------------------------------------------
 2 this is a test
 3 Do you like awk
 This's a test
 10 There are orange apple
 # 或者使用内建变量
 $ awk 'BEGIN{FS=","} {print $1,$2}'     log.txt
 ---------------------------------------------
 2 this is a test
 3 Do you like awk
 This's a test
 10 There are orange apple
 # 使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割
 $ awk -F '[ ,]'  '{print $1,$2,$5}'   log.txt
 ---------------------------------------------
 2 this test
 3 Are awk
 This's a
 10 There apple
```

用法三：

```
awk -v  # 设置变量
```

实例：

```
 $ awk -va=1 '{print $1,$1+a}' log.txt
 ---------------------------------------------
 2 3
 3 4
 This's 1
 10 11
 $ awk -va=1 -vb=s '{print $1,$1+a,$1b}' log.txt
 ---------------------------------------------
 2 3 2s
 3 4 3s
 This's 1 This'ss
 10 11 10s
```

用法四：

```
awk -f {awk脚本} {文件名}
```

实例：

```
 $ awk -f cal.awk log.txt
```

------

## 运算符

| 运算符                  | 描述                             |
| :---------------------- | :------------------------------- |
| = += -= *= /= %= ^= **= | 赋值                             |
| ?:                      | C条件表达式                      |
| \|\|                    | 逻辑或                           |
| &&                      | 逻辑与                           |
| ~ 和 !~                 | 匹配正则表达式和不匹配正则表达式 |
| < <= > >= != ==         | 关系运算符                       |
| 空格                    | 连接                             |
| + -                     | 加，减                           |
| * / %                   | 乘，除与求余                     |
| + - !                   | 一元加，减和逻辑非               |
| ^ ***                   | 求幂                             |
| ++ --                   | 增加或减少，作为前缀或后缀       |
| $                       | 字段引用                         |
| in                      | 数组成员                         |

过滤第一列大于2的行

```
$ awk '$1>2' log.txt    #命令
#输出
3 Do you like awk
This's a test
10 There are orange,apple,mongo
```

过滤第一列等于2的行

```
$ awk '$1==2 {print $1,$3}' log.txt    #命令
#输出
2 is
```

过滤第一列大于2并且第二列等于'Are'的行

```
$ awk '$1>2 && $2=="Are" {print $1,$2,$3}' log.txt    #命令
#输出
3 Are you
```

------

## 内建变量

| 变量        | 描述                                              |
| :---------- | :------------------------------------------------ |
| $n          | 当前记录的第n个字段，字段间由FS分隔               |
| $0          | 完整的输入记录                                    |
| ARGC        | 命令行参数的数目                                  |
| ARGIND      | 命令行中当前文件的位置(从0开始算)                 |
| ARGV        | 包含命令行参数的数组                              |
| CONVFMT     | 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 |
| ERRNO       | 最后一个系统错误的描述                            |
| FIELDWIDTHS | 字段宽度列表(用空格键分隔)                        |
| FILENAME    | 当前文件名                                        |
| FNR         | 各文件分别计数的行号                              |
| FS          | 字段分隔符(默认是任何空格)                        |
| IGNORECASE  | 如果为真，则进行忽略大小写的匹配                  |
| NF          | 一条记录的字段的数目                              |
| NR          | 已经读出的记录数，就是行号，从1开始               |
| OFMT        | 数字的输出格式(默认值是%.6g)                      |
| OFS         | 输出字段分隔符，默认值与输入字段分隔符一致。      |
| ORS         | 输出记录分隔符(默认值是一个换行符)                |
| RLENGTH     | 由match函数所匹配的字符串的长度                   |
| RS          | 记录分隔符(默认是一个换行符)                      |
| RSTART      | 由match函数所匹配的字符串的第一个位置             |
| SUBSEP      | 数组下标分隔符(默认值是/034)                      |

```
$ awk 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1         5    1
log.txt    2    2         5    2
log.txt    2    3         3    3
log.txt    2    4         4    4
$ awk -F\' 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1    '    1    1
log.txt    2    2    '    1    2
log.txt    2    3    '    2    3
log.txt    2    4    '    1    4
# 输出顺序号 NR, 匹配文本行号
$ awk '{print NR,FNR,$1,$2,$3}' log.txt
---------------------------------------------
1 1 2 this is
2 2 3 Are you
3 3 This's a test
4 4 10 There are
# 指定输出分割符
$  awk '{print $1,$2,$5}' OFS=" $ "  log.txt
---------------------------------------------
2 $ this $ test
3 $ Are $ awk
This's $ a $
10 $ There $
```

------

## 使用正则，字符串匹配

```
# 输出第二列包含 "th"，并打印第二列与第四列
$ awk '$2 ~ /th/ {print $2,$4}' log.txt
---------------------------------------------
this a
```

**~ 表示模式开始。// 中是模式。**

```
# 输出包含 "re" 的行
$ awk '/re/ ' log.txt
---------------------------------------------
3 Do you like awk
10 There are orange,apple,mongo
```

------

## 忽略大小写

```
$ awk 'BEGIN{IGNORECASE=1} /this/' log.txt
---------------------------------------------
2 this is a test
This's a test
```

------

## 模式取反

```
$ awk '$2 !~ /th/ {print $2,$4}' log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo
$ awk '!/th/ {print $2,$4}' log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo
```

------

## awk脚本

关于 awk 脚本，我们需要注意两个关键词 BEGIN 和 END。

- BEGIN{ 这里面放的是执行前的语句 }
- END {这里面放的是处理完所有的行后要执行的语句 }
- {这里面放的是处理每一行时要执行的语句}

假设有这么一个文件（学生成绩表）：

```
$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62
```

我们的 awk 脚本如下：

```
$ cat cal.awk
#!/bin/awk -f
#运行前
BEGIN {
    math = 0
    english = 0
    computer = 0
 
    printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
    printf "---------------------------------------------\n"
}
#运行中
{
    math+=$3
    english+=$4
    computer+=$5
    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
}
#运行后
END {
    printf "---------------------------------------------\n"
    printf "  TOTAL:%10d %8d %8d \n", math, english, computer
    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
}
```

我们来看一下执行结果：

```
$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00
```

------

## 另外一些实例

AWK 的 hello world 程序为：

```
BEGIN { print "Hello, world!" }
```

计算文件大小

```
$ ls -l *.txt | awk '{sum+=$5} END {print sum}'
--------------------------------------------------
666581
```

从文件中找出长度大于 80 的行：

```
awk 'length>80' log.txt
```

打印九九乘法表

```
seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i<=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'
```



# 实验7

实验报告内容:

## 1

> 查阅资料，根据自己的理解，回答什么是shell脚本。

Shell脚本是一种用于自动化执行命令的脚本语言，通常用于Linux或Unix操作系统。它是一系列命令的集合，可以通过Shell程序解释和执行。

## 2

> shell脚本有几种运行方式，它们的区别是什么?

Shell脚本主要有两种运行方式：

1.  作为可执行程序：将脚本文件设置为可执行权限（使用`chmod +x`命令），然后直接运行。
2.  通过Shell解释器直接调用：使用命令如`sh script.sh`或`bash script.sh`来执行。

两者的区别主要在于是否需要明确指定使用哪个Shell解释器。

## 3

> 如何使脚本可执行?

使用`chmod +x script.sh`命令给予脚本文件执行权限。

## 4

> 在shell脚本中，如何写入注释?写注释的目的是什么?

注释使用`#`符号开始，例如：

```shell
# 这是一个注释。
```

注释的目的是解释代码的功能或目的，以便于阅读和维护。

## 5

> shell脚本的预设变量:
> 怎么向脚本传入第1个参数、第2个参数
> 如何获得脚本名、脚本所有参数、脚本参数个数

+   向脚本传入参数：使用`$1`来表示第一个参数，`$2`表示第二个参数。
+   获得脚本名：使用`$0`。
+   获得所有参数：使用`$@`或`$*`。
+   获得参数个数：使用`$#`。

## 6

> 如何让shell脚本得到来自终端的输入?用例子验证。

```shell
echo "请输入一个值："
read value
echo "您输入的值是：$value"
```



## 7

> 编写shell脚本，实现:输入两个字符串，输出这两个字符串的连接起来的字
> 符串(需实现4种形式连接，见例子)。 如输入字符串hello和字符串linux，输出
> (1) hellolinux
> (2)  hello linux
> (3)  hello: linux
> (4)  hello LINUX

```shell
#!/bin/bash
echo "请输入两个字符串："
read str1 str2
echo "(1) $str1$str2"
echo "(2) $str1 $str2"
echo "(3) $str1: $str2"
echo "(4) $str1 ${str2^^}"

```



## 8

> 两个整数相加，有4种实现方法，分别是什么，用例子验证。

1.  使用`expr`命令：`sum=$(expr $a + $b)`
2.  使用双括号：`sum=$((a + b))`
3.  使用`let`命令：`let sum=a+b`
4.  使用`bc`命令：`sum=$(echo "$a + $b" | bc)`

## 9

> 编写shell脚本，实现:检查某一目录下是否存在某个文件，存在与否都要输出相应提示信息。

```shell
#!/bin/bash
echo "请输入文件名："
read filename
if [ -f "$filename" ]; then
    echo "文件存在"
else
    echo "文件不存在"
fi

```



## 10

> 脚本的第一行#! /bin/bash表示什么意思?

这是一个Shebang行，指定脚本应当使用哪个解释器来执行，这里指定的是Bash。

## 11

> [ $a == $b ] 和 [ \$a -eq\$b ] 有什么区别?

`[ $a == $b ]`用于字符串比较，而`[ $a -eq $b ]`用于整数比较。

## 12

> = 和 == 有什么区别?

在Shell脚本中，`=` 用于赋值，`==` 用于字符串比较。

## 13

> 课本p187的12.7的shell脚本练习题，添加代码注释，运行验证。

1.   编写shell脚本，计算1~100的和。
2.   编写shell脚本，输入一个数字n并计算1 ~n的和。要求:如果输人的数字小于1，则重新输入， 直到输人正确的数字为止。
3.   编写shell脚本 ，把/root/目录下的所有目录(只需要一级)复制到/imp/目录下。
4.   编写shell脚本，批量建立用户user _00、user _O1.. user_99。要求:所有用户同属于users组。 
5.   编写shell脚本，截取文件test. log中包含关键词abc的行中的第1列(假设分隔符为:)，然后把截 取的数字排序(假设第1列为数字)，最后打印出重复超过10次的列。
6.   编 写 s h e l l 脚 本 ，判 断 输 人的 I P 是 否 正 确 。要 求 :I P 的 规 则 是 n 1 . n 2 . n 3 . n 4 ，其 中 1 < n 1 < 2 5 5 , 0 < n 2 < 2 5 5 ， 0<n3<255, 0<n4<255 ).

```shell
#!/bin/bash
# 计算1到100的和

sum=0
for i in {1..100}; do
    sum=$((sum + i))
done

echo "The sum of numbers from 1 to 100 is: $sum"

```

```shell
#!/bin/bash
# 计算1到n的和，n是用户输入的数字

sum=0
while true; do
    read -p "Enter a number (>=1): " n
    if [[ $n -ge 1 ]]; then
        for i in $(seq 1 $n); do
            sum=$((sum + i))
        done
        echo "The sum of numbers from 1 to $n is: $sum"
        break
    else
        echo "Please enter a number greater than or equal to 1."
    fi
done

```

```shell
#!/bin/bash
# 复制/root/目录下的所有一级目录到/imp/目录

mkdir -p /imp
for dir in /root/*/; do
    cp -r "$dir" /imp/
done

```

```shell
#!/bin/bash
# 批量创建用户user_00到user_99，并加入users组

for i in $(seq -w 0 99); do
    useradd -m "user_$i"
    usermod -aG users "user_$i"
done

```

```shell
#!/bin/bash
# 截取包含关键词abc的行的第1列并排序，打印重复超过10次的列

awk -F ':' '/abc/ {print $1}' test.log | sort | uniq -c | awk '$1 > 10 {print $2}'

```

```shell
#!/bin/bash
# 判断输入的IP是否正确

read -p "Enter an IP address: " ip

if [[ $ip =~ ^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$ ]]; then
    echo "The IP address $ip is valid."
else
    echo "The IP address $ip is not valid."
fi

```



## 14

> 编写一个shell脚本，实现两个变量之间的加减乘除以及求余运算。实现哪种 运算(加、减、乘、除、求余)，取决于用户的输入。运行验证。

```shell
#!/bin/bash
echo "请输入两个数字："
read a b
echo "选择运算：加(1) 减(2) 乘(3) 除(4) 求余(5)"
read op
case $op in
    1) result=$((a + b)) ;;
    2) result=$((a - b)) ;;
    3) result=$((a * b)) ;;
    4) result=$((a / b)) ;;
    5) result=$((a % b)) ;;
    *) echo "无效输入" && exit 1 ;;
esac
echo "结果：$result"

```



## 15

> 编写shell脚本，提示用户输入linux或python(不区分大小写),并判断用户输入的是linux还是python,或是其它信息。运行验证。

```shell
#!/bin/bash
echo "请输入'linux'或'python'（不区分大小写）："
read input
case "${input,,}" in
    linux) echo "您输入的是linux" ;;
    python) echo "您输入的是python" ;;
    *) echo "输入了其他信息" ;;
esac

```



## 16

> 编写shell脚本，计算0-50以内所有偶数之和。运行验证。

```shell
#!/bin/bash
sum=0
for (( i=0; i<=50; i+=2 ))
do
    sum=$((sum + i))
done
echo "0到50内所有偶数的和是：$sum"

```



## 17

> 编写shell脚本，首先生成10个随机数字，并输出这个10数字，同时显示其中的最大值和最小值。

```shell
#!/bin/bash
echo "10个随机数："
for i in {1..10}; do
    num=$((RANDOM % 100))
    echo $num
    nums[$i]=$num
done
min=${nums[1]}
max=${nums[1]}
for n in ${nums[@]}; do
    ((n > max)) && max=$n
    ((n < min)) && min=$n
done
echo "最大值：$max, 最小值：$min"

```




## 18

> 编写shell脚本，在一个目录下的所有文件的文件名后面加“test”。

```shell
#!/bin/bash
for file in *; do
    mv "$file" "${file}test"
done

```



## 19

> 阐述break、continue、exit在循环中的作用，并编写shell脚本验证。

+   `break`：退出循环。
+   `continue`：跳过当前循环迭代，继续下一个迭代。
+   `exit`：退出脚本。

```shell
#!/bin/bash

echo "演示break命令："
for i in {1..5}; do
    if [ $i -eq 3 ]; then
        break
    fi
    echo "循环次数：$i"
done

echo "演示continue命令："
for i in {1..5}; do
    if [ $i -eq 3 ]; then
        continue
    fi
    echo "循环次数：$i"
done

echo "演示exit命令："
for i in {1..5}; do
    echo "循环次数：$i"
    if [ $i -eq 3 ]; then
        echo "exit命令将终止脚本"
        exit
    fi
done

```



## 20

> 结合所学，写 3 个 shell 脚本， 并说明他们实现了什么功能。

1.   检测网站可用性脚本

```shell
#!/bin/bash

sites=("http://baidu.com" "http://google.com" "http://github.com")
for site in "${sites[@]}"
do
  status=$(curl -o /dev/null -s -w "%{http_code}\n" $site)
  if [ $status -eq 200 ]; then
    echo "网站 $site 可访问"
  else
    echo "网站 $site 不可访问, 状态码: $status"
  fi
done

```

2.   系统信息报告脚本

```shell
#!/bin/bash

echo "主机名：$(hostname)"
echo "系统运行时间：$(uptime -p)"
echo "当前用户：$(whoami)"
echo "网络配置："
ifconfig

```

3.   监控CPU和内存使用率脚本

```shell
#!/bin/bash

while true; do
    echo "--- $(date) ---"
    echo "CPU和内存使用情况:"
    uptime
    echo "内存使用情况:"
    free -h
    echo "-----------------------"
    sleep 2
done

```



## 21

> 本地主机为Linux系统，远程登录服务器Linux系统，有几种方式，分别是什么，有什么特点、优缺点?

1.  **SSH**: SSH是一种加密的网络协议，可以在不安全的网络中为远程登录提供安全的通信环境。它是Linux系统中最常用的远程登录方式之一。SSH具有安全性高、稳定性好、支持多种加密算法等优点。但是，SSH需要在服务器上安装SSH服务，且在使用时需要输入用户名和密码，不够方便。
2.  **VNC**: VNC是一种远程桌面协议，可以在不同的操作系统之间共享桌面。它可以在图形界面下远程登录Linux服务器，支持多用户同时登录，且可以在不同的操作系统之间共享桌面。但是，VNC的安全性较差，需要在服务器上安装VNC服务。
3.  **Telnet**: Telnet是一种远程登录协议，可以在不安全的网络中为远程登录提供通信环境。它是Linux系统中最早的远程登录方式之一，但是由于其安全性较差，现在已经很少使用了。

## 22

> 本地主机为windows系统，远程登录服务器Linux系统，有几种方式，分别是什么，有什么特点、优缺点?

1.  **SSH (Secure Shell) 使用客户端如PuTTY**
	+   特点：SSH是最常用的安全远程登录方法。PuTTY是一个流行的SSH和Telnet客户端，用于Windows系统。
	+   优点：提供安全的加密连接，支持命令行操作，支持文件传输（使用额外工具如WinSCP）。
	+   缺点：只提供文本界面，初次配置可能稍显复杂。
2.  **Windows Subsystem for Linux (WSL)**
	+   特点：WSL允许在Windows上运行Linux环境，可以直接使用Linux命令行工具。
	+   优点：无需额外软件即可直接在Windows中使用Linux命令行。
	+   缺点：并非完整的Linux系统，某些特定的Linux功能可能不支持。
3.  **VNC (Virtual Network Computing)**
	+   特点：提供图形界面的远程访问。
	+   优点：能够访问Linux的图形界面，适合需要图形界面操作的场景。
	+   缺点：配置相对复杂，对网络带宽要求较高，安全性低于SSH。
4.  **RDP (Remote Desktop Protocol) 通过第三方软件**
	+   特点：RDP是Windows系统中常用的远程桌面协议，可通过第三方软件在Linux上实现。
	+   优点：提供完整的桌面体验。
	+   缺点：需要在Linux服务器上安装和配置额外的软件，比如xrdp。
5.  **远程桌面管理器（如Remote Desktop Manager, mRemoteNG）**
	+   特点：这些管理器集成了多种远程桌面协议。
	+   优点：一个工具内支持多种协议，方便管理多个远程连接。
	+   缺点：配置相对复杂，有些功能可能需要付费版。

# 实验8

实验报告:

## 1 

> basename、dirname、paste命令的熟练掌握。自己设计场景，实现basename、 dirname、paste的使用，要求每条命令使用3次。

```bash
#!/bin/bash

# 创建命令列表
commands=(
    "basename /usr/bin/sort"
    "basename /var/log/syslog.log .log"
    "basename /home/user/document.txt"
    "dirname /usr/bin/sort"
    "dirname /var/log/syslog.log"
    "dirname /home/user/document.txt"
    "paste file1.txt file2.txt # 合并两个文件的内容（横向连接）"
    "paste -s file1.txt # 将一个文件的内容转换为单列"
    "paste -d ',' file1.txt file2.txt # 使用不同的分隔符合并文件内容"
)

# 遍历命令列表并执行
for cmd in "${commands[@]}"
do
    echo "Running: $cmd"
    eval $cmd
    echo
done

```

## 2

>   ACL知识点的熟练掌握，自己设计场景，要求实现:
>
>   +   为xx用户(自己额外创建的用户)赋予读写xx文件(自己创建的文件)的权限，并验证。
>   +   为xx用户(自己额外创建的用户)赋予读写xx目录(自己创建的目录)的权限，并验证。

```bash
#!/bin/bash

# 定义用户名、文件名和目录名
username="newuser"
filename="myfile.txt"
dirname="mydir"

echo "正在创建新用户: $username"
sudo useradd $username

echo "正在创建新文件: $filename，并为 $username 用户赋予读写权限"
touch $filename
setfacl -m u:$username:rw $filename

echo "正在创建新目录: $dirname，并为 $username 用户赋予读写权限"
mkdir $dirname
setfacl -m u:$username:rw $dirname

echo "输出 $filename 的 ACL 设置:"
getfacl $filename

echo "输出 $dirname 的 ACL 设置:"
getfacl $dirname

# 删除操作
echo "正在删除用户: $username"
sudo userdel $username

echo "脚本执行完成。"

```

## 3

>   在Linux环境下，自己创建一个C++程序(要求:包含多个文件)，并进行运行(可执行文件)。

项目结构图:

```
hello_world_program/
|
|--	main.cpp
|--	hello.h
|--	hello.cpp
```

三个文件内容如下:

```c++
// hello.h
#ifndef HELLO_H
#define HELLO_H

void hello_world(); // 函数声明

#endif

```

```C++
// hello.cpp
#include <iostream>
#include <chrono>
#include <format>
#include "hello.h"

void hello_world() {
    std::cout << "hello world" << std::endl;
    auto now = std::chrono::system_clock::now();

    // 转换为time_t对象
    std::time_t now_time = std::chrono::system_clock::to_time_t(now);

    // 转换为可读的形式
    std::cout << std::format("Current Time:{}", std::ctime(&now_time)) << std::endl;
}


```

```c++
// main.cpp
#include "hello.h"

int main() {
    hello_world();
    return 0;
}

```

运行:
不使用cmake:

```bash
g++ -std=c++20 main.cpp hello.cpp -o hello_world_program # 使用C++20标准编译

./hello_world_program
```

使用cmake:

CMakeLists.txt内容:

```cmake
cmake_minimum_required(VERSION 3.10)
project(HelloWorldProject)

# 设置 C++ 标准
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 包含头文件
include_directories(${PROJECT_SOURCE_DIR})

# 指定生成目标
add_executable(HelloWorld main.cpp hello.cpp)

```

项目结构图

```
hello_world_program/
|
|--	main.cpp
|--	hello.h
|--	hello.cpp
|--	CMakeLists.txt
```

编译过程

```bash
cmake .
make
./HelloWorld

```

## 4

[教程](https://help.aliyun.com/zh/ecs/use-cases/build-a-lamp-stack-on-ubuntu-instances)

## basename

basename命令主要用于显示文件路径名剔除目录部分后的显示文件名。如何指定了后缀参数suffix，同时也删除文件的扩展名。其中，name是文件的路径名，suffix是文件名的后缀。



### 语法格式

```
basename [参数]
```

### 常用参数：



| --help    | 显示命令的简单说明与用法等帮助信息，然后退出 |
| --------- | -------------------------------------------- |
| --version | 显示命令的版本与作者等信息，然后退出         |

### 参考实例



显示文件路径名/usr/bin/sort的基本文件名sort：

```
[root@coonote ~]# basename /usr/bin/sort
```

## dirname

**Linux dirname命令**去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个`/`及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个`/`后无字符，dirname 命令使用倒数第二个`/`，并忽略其后的所有字符。dirname 和 basename 通常在 [shell](https://www.coonote.com/shell/shell-tutorial.html) 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。

### 语法 

```bash
dirname(选项)(参数)
```

### 选项 

```bash
--help：显示帮助；
--version：显示版本号。
```

### 实例 

```bash
dirname //
结果为 /

dirname /a/b/
结果为：/a

dirname a
结果为 .

dirname a/b
结果为路径名 a
```

## paste

Linux paste 命令用于合并文件的列。

paste 指令会把每个文件以列对列的方式，一列列地加以合并。

### 语法

```
paste [-s][-d <间隔字符>][--help][--version][文件...]
```

**参数**：

- -d<间隔字符>或--delimiters=<间隔字符> 　用指定的间隔字符取代跳格字符。
- -s或--serial 　串列进行而非平行处理。
- --help 　在线帮助。
- --version 　显示帮助信息。
- [文件…] 指定操作的文件路径

### 实例

使用paste指令将文件"file"、"testfile"、"testfile1"进行合并，输入如下命令：

```
paste file testfile testfile1 #合并指定文件的内容 
```

但是，在执行以上命令之前，首先使用"cat"指令对3个文件内容进行查看，显示如下所示：

```
$ cat file                  #file文件的内容  
xiongdan 200  
lihaihui 233  
lymlrl 231  
$ cat testfile              #testfile文件的内容  
liangyuanm  ss  
$ cat testfile1             #testfile1文件的内容  
huanggai 56  
zhixi 73 
```

当合并指令"$ paste file testfile testfile1"执行后，程序界面中将显示合并后的文件内容，如下所示：

```
xiongdan 200  
lihaihui 233  
lymlrl 231  
liangyuanm  ss  
huanggai 56  
zhixi 73  
```

若使用paste指令的参数"-s"，则可以将一个文件中的多行数据合并为一行进行显示。例如，将文件"file"中的3行数据合并为一行数据进行显示，输入如下命令

```
$ paste -s file             #合并指定文件的多行数据
```

上面的命令执行后，显示的数据内容如下所示：

```
xiongdan 200 lihaihui 233 lymlrl 231 
```

注意：参数"-s"只是将testfile文件的内容调整显示方式，并不会改变原文件的内容格式。
