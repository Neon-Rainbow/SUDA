# 算法期末复习

## 动态规划,贪心算法,分治算法区别

## 动态规划

关键词:

+   无后效性:在给定当前的状态和的决策（动作）下，系统的下一个状态仅取决于当前状态和决策，并且与如何达到当前状态或未来决策无关
+   最优子结构:一个问题的最优解一定包含其子问题的最优解

### LCS

>   给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在**公共子序列** ，返回 `0` 。
>
>   一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
>   +   例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。
>
>   两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。
>
>   **示例 1：**
>
>   ```
>   输入：text1 = "abcde", text2 = "ace" 
>   输出：3  
>   解释：最长公共子序列是 "ace" ，它的长度为 3 。
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：text1 = "abc", text2 = "abc"
>   输出：3
>   解释：最长公共子序列是 "abc" ，它的长度为 3 。
>   ```
>
>   **示例 3：**
>
>   ```
>   输入：text1 = "abc", text2 = "def"
>   输出：0
>   解释：两个字符串没有公共子序列，返回 0 。
>   ```

构建二维$dp$数组,其中$dp[i][j]$表示$text_1[0:i]$与$text_2[0:j]$中的公共子序列的长度

状态转移方程:
$$
dp[i][j] = 
\begin{cases}
0 & i = 0\ or\ j = 0 \\
dp[i - 1][j - 1] + 1 & text_1[i - 1] = text_2[j - 1] \\
max(dp[i - 1][j], dp[i][j - 1]) & text_1[i - 1] \neq text_2[j - 1]
\end{cases}
$$
$dp数组的边界条件$:

+   当 $i = 0$时,$text_1[0:i]$为空,因此$text_1[0:i]与text_2[0:j]$的公共子序列长度一定为0,$dp[0][j] = 0$
+   当$j = 0$时,同理可得$dp[i][0] = 0$

![image.png](./assets/1617411822-KhEKGw-image.png)

### 背包问题

#### 01背包问题

**给定物品价值与体积（对应了「给定价值与成本」），在规定容量下（对应了「限定决策规则」）如何使得所选物品的总价值最大。**

>   有$N$件物品和一个容量是$V$的背包。每件物品有且只有一件。
>
>   第$i$件物品的体积是$v[i]$，价值是$w[i]$。
>
>   求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

$dp[i][c]的含义:考虑前i件物品，使用容量不超过c的条件下的背包最大价值。$

对于第$i$件物品有两个选择:拿或不拿

拿:此时$dp[i][c]$表示的为$考虑前i件物品，使用容量不超过c$,但是由于第$i$件物品没有拿,因此与$考虑前i - 1件物品，使用容量不超过c$一样,即$dp[i][c] = dp[i - 1][c]$

不拿:此时在拿了第$i$件物品后,背包的容量减少了$v[i]$,但是背包的价值增加了$w[i]$,即$dp[i][c] = dp[i - 1][c - v[i]] + w[i]$

两者取大的,最终的状态转移方程:

$dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - v[i]] + w[i])$

一维空间优化:

$dp[c] = max(dp[c], dp[c - v[i]] + w[i])$

#### 完全背包问题

>   有$N$件物品和一个容量是$V$的背包。每件物品有无数件。
>
>   第$i$件物品的体积是$v[i]$，价值是$w[i]$。
>
>   求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

$dp[i][c] = max(dp[i - 1][c], dp[i][c - v[i]] + w[i])$

##### 例题1:硬币兑换

>   给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
>   计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
>   你可以认为每种硬币的数量是无限的。
>
>   **示例 1：**
>
>   ```
>   输入：coins = [1, 2, 5], amount = 11
>   输出：3 
>   解释：11 = 5 + 5 + 1
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：coins = [2], amount = 3
>   输出：-1
>   ```
>
>   **示例 3：**
>
>   ```
>   输入：coins = [1], amount = 0
>   输出：0
>   ```

二维dp:

$dp[i][j]$指的是使用前$i$个硬币,凑出$j$元,所需要的最少的硬币数量

对于第$i$个硬币,可以选,也可以不选择

不选:$dp[i][j] = dp[i - 1][j]$

选:$dp[i][j] = dp[i][j - coin[i]] + 1$(最优子结构)

因此状态转移方程为$dp[i][j] = min(dp[i - 1][j], dp[i][j - coin[i]] + 1)$

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n: int = len(coins)
        @cache
        def dfs(i: int, j: int) -> int:
            if j < 0:
                return amount + 1
            if j == 0:
                return 0
            if i == 0:
                return amount + 1
            return min(dfs(i - 1, j), dfs(i, j - coins[i - 1]) + 1)
        ans: int = dfs(n, amount)
        if ans == amount + 1:
            return -1
        return ans 
```

空间压缩:

$dp[i] = min(dp[i], dp[i - coins[j]] + 1)$

##### 例题2:完全平方数

>   给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。
>
>   **完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。
>
>   **示例 1：**
>
>   ```
>   输入：n = 12
>   输出：3 
>   解释：12 = 4 + 4 + 4
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：n = 13
>   输出：2
>   解释：13 = 4 + 9
>   ```

二维dp:

$dp[i][j]$指的是使用前$i$个数,凑出$j$,需要的最小的数的个数

$dp[i][j] = min(dp[i - 1][j], dp[i][j - i*i] + 1)$

```python
class Solution:
    def numSquares(self, n: int) -> int:
        @cache
        def dfs(i: int, j: int) -> int:
            if i <= 0:
                return inf
            if j == 0:
                return 0
            if j < 0:
                return inf
            return min(dfs(i - 1, j), dfs(i, j - i * i) + 1)
        return dfs(int(n ** 0.5), n)
```

##### 例题3:切割钢条

第$i$种钢条的长度为$length[i]$,价值为$price[i]$

不用看书上晦涩的伪代码,书上做的只是多了一步状态压缩的过程

可以理解为完全背包问题,$dp[i][j]$指选择前$i$种长度的钢条,总长度为$j$,此时的最大价值

$dp[i][j] = max(dp[i - 1][j], dp[i][j - length[i]] + price[i])$
